<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于Linux的HA高可用服务搭建</title>
    <url>/2024/12/04/HA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="HA高可用服务搭建"><a href="#HA高可用服务搭建" class="headerlink" title="HA高可用服务搭建"></a>HA高可用服务搭建</h2><h4 id="1、HA-Cluster高可用集群"><a href="#1、HA-Cluster高可用集群" class="headerlink" title="1、HA Cluster高可用集群"></a>1、HA Cluster高可用集群</h4><p>HA是High Available缩写。 HA Cluster是指高可用性集群，是保证业务连续性的有效解决方案，一般 有两个或两个以上的节点，且分为活动节点及备用节点。 </p>
<p>FailOver：故障自动切换，MASTER&#x2F;BACKUP，MASTER宕机了，BACKUP 充当主机使用。 </p>
<h4 id="2、为什么要引入HA高可用"><a href="#2、为什么要引入HA高可用" class="headerlink" title="2、为什么要引入HA高可用"></a>2、为什么要引入HA高可用</h4><p>答：主要是为了解决Web服务的单点故障。 HA高可用软件架构原理：keepalived&#x2F;mha</p>
<h4 id="3、Keepalived软件概述"><a href="#3、Keepalived软件概述" class="headerlink" title="3、Keepalived软件概述"></a>3、Keepalived软件概述</h4><p>Keepalived软件起初是专为LVS负载均衡软件设计的，用来管理并监控LVS 集群系统中各个服务节点的状态，后来又加入了可以实现高可用的VRRP功 能。因此，Keepalived除了能够管理LVS软件外，还可以作为其他服务 （例如：Nginx、HAproxy、MySQL等）的高可用解决方案软件。 </p>
<h4 id="4、Keepalived组成和原理"><a href="#4、Keepalived组成和原理" class="headerlink" title="4、Keepalived组成和原理"></a>4、Keepalived组成和原理</h4><p>Keepalived软件主要是通过VRRP协议实现高可用功能的（故障切换方 式）。VRRP是Virtual Router RedundancyProtocol(虚拟路由器冗余协 议）的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，它 能够保证当个别节点宕机时，整个网络可以不间断地运行。 （FailOver+VIP漂移）</p>
<p> 使用Keepalived进行VIP（虚拟的IP地址），所有服务器共享一个虚拟的 VIP的实现。 </p>
<p>虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供 相同功能的路由器组成一个路由器组，这个组里面有一个master和多个 backup，master上面有一个对外提供服务的vip（该路由器所在局域网内 其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp 包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个 backup当master。这样的话就可以保证路由器的高可用了。 </p>
<p>Keepalived的功能体系结构，大致分两层：<strong>用户空间（user space）和内 核空间（kernel space）</strong>。 </p>
<p>内核空间：主要包括IPVS（IP虚拟服务器，用于实现网络服务的负载均 衡）和NETLINK（提供高级路由及其他相关的网络功能）两个部份。 </p>
<p>用户空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WatchDog：负则监控checkers和VRRP进程的状况</span><br><span class="line">VRRP Stack：负载均衡器之间的失败切换FailOver，如果只用一个负载均衡</span><br><span class="line">器，则VRRP不是必须的。</span><br><span class="line">Checkers：负责真实服务器的健康检查healthchecking，是keepalived</span><br><span class="line">最主要的功能。换言之，可以没有VRRP Stack，但健康检查</span><br><span class="line">healthchecking是一定要有的。</span><br><span class="line">IPVS wrapper：用户发送设定的规则到内核ipvs代码.</span><br><span class="line">Netlink Reflector：用来设定vrrp的vip地址等。</span><br></pre></td></tr></table></figure>

<p> keepalived主要使用三个模块，分别是core、check和vrrp。core模块为 keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和 解析。check负责健康检查，包括常见的各种检查方式。vrrp模块是来实现 VRRP协议的。 </p>
<h4 id="5、安装Keepalived软件"><a href="#5、安装Keepalived软件" class="headerlink" title="5、安装Keepalived软件"></a>5、安装Keepalived软件</h4><p>第一步：关闭防 火墙与SELinux、关闭NetworkManager、时间同步。 </p>
<p>第二步：在Web01与Web02（两台机器组建高可用集群）使用yum命令安 装Keepalived软件 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure>

<p>第三步：了解keepalived配置文件与日志信息输出的位置</p>
<p>配置文件： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></table></figure>

<p>日志文件： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/messages</span><br></pre></td></tr></table></figure>

<h4 id="6、设置Keepalived配置文件"><a href="#6、设置Keepalived配置文件" class="headerlink" title="6、设置Keepalived配置文件"></a>6、设置Keepalived配置文件</h4><p>Web01与Web02同时操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalived/keepalived.conf </span><br></pre></td></tr></table></figure>

<p>第一步：使用冒号：末行模式，切换光标到35行，然后按dG，删除35行以 后的所有内容 </p>
<p>第二步：了解一下配置文件中每一行的含义19~34行 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_instance <span class="comment">#组建vrrp实例组的组名（Web01与Web02要保持一致） &#123;</span></span><br><span class="line">	state <span class="comment">#角色名称(MASTER/BACKUP)</span></span><br><span class="line">	interface <span class="comment">#网卡名称(eth0=&gt;ens33)</span></span><br><span class="line">	virtual_router_id <span class="comment">#vrrp组的编号（Web01与Web02要保持一致）</span></span><br><span class="line">	priority <span class="comment">#权重（选举=&gt;权重高=&gt;当选几率大）</span></span><br><span class="line">	advert_int 1 <span class="comment">#心跳间隔时间</span></span><br><span class="line">	authentication &#123;</span><br><span class="line">		auth_type PASS <span class="comment">#=&gt; 授权类型（PASS密码）</span></span><br><span class="line">		auth_pass 1111 <span class="comment">#=&gt; 组密码（想组建集群，其密码必须一致）</span></span><br><span class="line">	&#125;</span><br><span class="line">	virtual_ipaddress &#123;</span><br><span class="line">		10.1.1.100 <span class="comment">#=&gt; VIP，虚拟的IP地址，需要与集群中的机器保持在同一网段</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>设置完成后，保存并退出</p>
<p>第三步：启动Keepalived软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start keepalived</span><br><span class="line">systemctl status keepalived</span><br></pre></td></tr></table></figure>

<p>分别在Web01&#x2F;Web02中使用ip a命令，查看网卡上是否挂载VIP地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>

<p>7、解析<a href="http://www.shop.com到vip虚拟ip地址/">www.shop.com到VIP虚拟IP地址</a></p>
<p> Windows中找到hosts文件： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip 域名</span><br><span class="line">例如：</span><br><span class="line">192.168.1.100 www.baidu.com</span><br></pre></td></tr></table></figure>

<p>8、让VIP可以ping通</p>
<p>把域名解析到VIP，通过VIP访问到提供服务的服务器。 </p>
<p><strong>特别注意：1.3以后版本要注释vrrp_strict，否则虚拟IP无法ping通</strong> </p>
<p>设置完成后，重启keepalived软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart keepalived</span><br></pre></td></tr></table></figure>

<p> 9、模拟服务器故障，VIP漂移</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MASTER：网络无法连接，keepalived软件关闭</span><br><span class="line">Web01 <span class="comment"># systemctl stop network</span></span><br></pre></td></tr></table></figure>

<p>10、让Keepalived可以监测Nginx服务</p>
<p>问题：当我们在MASTER服务器中，手工停止Nginx，VIP会发生漂移么？ </p>
<p>答：不会，因为keepalived软件主要检测keepalived服务状态以及网络情 况。只要这两者正常，这个VIP就不会发生漂移。 </p>
<p><strong>这个时候就产生了一个问题：Nginx都已经停止了，实际上这台MASTER服 务器就无法对外提供Web服务了，所以这个时候VIP也应该正常发生漂移。</strong> </p>
<p>第一步：编写nginx.sh脚本，自动检测Nginx的运行状态 （Web01&#x2F;Web02） </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir /scripts</span></span><br><span class="line"><span class="comment"># vim /scripts/nginx.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">nginx_status=`ps -C nginx --no-header |<span class="built_in">wc</span> -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$nginx_status</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">	systemctl stop keepalived</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>第二步：给nginx.sh文件添加一个可执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /scripts/nginx.sh</span><br></pre></td></tr></table></figure>

<p>设置完成后，不要着急继续向下操作。首先测试一下nginx.sh脚本是否可用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/scripts/nginx.sh</span><br></pre></td></tr></table></figure>

<p>第三步：在Web01&#x2F;Web02两台机器的keepalived.conf文件中配置 nginx.sh脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line">vrrp_script 健康检测脚本对象名称 &#123;</span><br><span class="line">	script STRING | QUOTED-STRING <span class="comment">## 指定：&lt;外部脚本&gt;的&lt;调用路径&gt;</span></span><br><span class="line">	interval INTEGER <span class="comment">## 设置：&lt;健康跟踪检测&gt;的&lt;时间间隔&gt;，默认为 1 秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上只是在keepalived配置文件中定义了一个检测脚本，但是还没有真正 的调用。 </p>
<p>第四步：在vrrp_instance标签中真正调用check_nginx这个检测脚本 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">...</span><br><span class="line">track_script &#123;</span><br><span class="line">check_nginx</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第五步：设置完成后，重启keepalived</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart keepalived</span><br></pre></td></tr></table></figure>

<h2 id="二、Keepalived配置补充"><a href="#二、Keepalived配置补充" class="headerlink" title="二、Keepalived配置补充"></a>二、Keepalived配置补充</h2><p>1、抢占与非抢占模式 </p>
<p>☆ 什么是抢占模式</p>
<p>MASTER：权重100 </p>
<p>BACKUP：权重90 </p>
<p>当MASTER发生故障时（宕机），VIP会自动从MASTER漂移到BACKUP服 务器。但是当MASTER维修完毕后，启动keepalived的瞬间，其就会把VIP 从BACKUP服务器中抢占过来。我们把这种情况就称之为“抢占模式”。 </p>
<p>扩展：keepalived中，到底是如何决定谁是MASTER？ </p>
<p>答：主要通过权重配置以及IP地址的大小 </p>
<p>① 如果Web01与Web02其权重不同，当我们同时启动keepalived的时候， 其默认会选择权重比较大的服务器充当MASTER。 </p>
<p>② 如果Web01与Web02其权重相同，则IP地址大的，优先成为MASTER Web02（10.1.1.13） &gt; Web01（10.1.1.11）</p>
<h4 id="☆-非抢占模式"><a href="#☆-非抢占模式" class="headerlink" title="☆ 非抢占模式"></a>☆ 非抢占模式</h4><p>问题：如果让我们的HA Cluster集群成为非抢占模式呢？ </p>
<p>答：一共分三步 </p>
<p>第一步：更改keepalived.conf配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">	virtual_router_id 51</span><br><span class="line">------------------------ 华丽的分割线 ------------------</span><br><span class="line">	nopreempt =&gt; 非抢占模式</span><br><span class="line">------------------------ 华丽的分割线 ------------------</span><br><span class="line">	priority 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：配置state角色都为BACKUP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">------------------------ 华丽的分割线 ------------------</span><br><span class="line">	state BACKUP =&gt; 所有服务器都设置为BACKUP，没有MASTER/BACKUP之分</span><br><span class="line">------------------------ 华丽的分割线 ------------------</span><br><span class="line">	virtual_router_id 51</span><br><span class="line">	nopreempt</span><br><span class="line">	priority 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：重启keepalived软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart keepalived</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作基础</title>
    <url>/2024/11/30/Linux%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1）Linux新手教程"><a href="#1）Linux新手教程" class="headerlink" title="1）Linux新手教程"></a>1）Linux新手教程</h1><h2 id="一、Linux状态提示符"><a href="#一、Linux状态提示符" class="headerlink" title="一、Linux状态提示符"></a>一、Linux状态提示符</h2><p>[root@localhost ~]#<br>解析： [         root            	  @        	      localhost   		      ~    	 	]        #<br>    当前登录名称	登录在	当前登录的主机名称		当前所在的目录名称	       身份标志符<br>                            ~表示在家目录	    #表示超级管理员<br>——————————————————————————————————————————————————<br>[root@localhost ~]#	<br>root用户登录在名为localhost的主机上面，目前位于家目录中，他的身份是超级管理员</p>
<p>[cxk@localhost root]$</p>
<h2 id="二、Linux帮助信息的查询"><a href="#二、Linux帮助信息的查询" class="headerlink" title="二、Linux帮助信息的查询"></a>二、Linux帮助信息的查询</h2><h3 id="1、Linux命令的种类"><a href="#1、Linux命令的种类" class="headerlink" title="1、Linux命令的种类"></a>1、Linux命令的种类</h3><p>内嵌命令：Linux内核自带的命令</p>
<p>外部命令：后期安装才能使用的命令</p>
<h3 id="2、区分命令类型"><a href="#2、区分命令类型" class="headerlink" title="2、区分命令类型"></a>2、区分命令类型</h3><p>命令：type<br>作用：检测命令类型<br>语法格式：type被查询的命令	cd	ls</p>
<h3 id="3、帮助信息的查询"><a href="#3、帮助信息的查询" class="headerlink" title="3、帮助信息的查询"></a>3、帮助信息的查询</h3><p>内嵌命令<br>    help被查询的命令<br>外部命令<br>    被查询的命令 –help</p>
<h2 id="三、Linux命令的基础语法格式"><a href="#三、Linux命令的基础语法格式" class="headerlink" title="三、Linux命令的基础语法格式"></a>三、Linux命令的基础语法格式</h2><p>命令由三部分组成</p>
<p>命令	选项	参数<br>动作	补充	操作对象</p>
<p>案例：<br>命令：ls<br>作用:查看目录下的文件名（默认查看当前目录）<br>语法格式：ls [选项]… [文件]…</p>
<p>[]：表示该项内容根据情况，可以写可以不写<br>…：表示该项内容根据情况，可以写一个或多个</p>
<h1 id="2-文件管理"><a href="#2-文件管理" class="headerlink" title="2)文件管理"></a>2)文件管理</h1><h2 id="一、认识Linux目录树"><a href="#一、认识Linux目录树" class="headerlink" title="一、认识Linux目录树"></a>一、认识Linux目录树</h2><p>了解Linux系统和windows系统的目录结构区别<br>Linux是一个单目录树结构，可以理解为只有c盘的操作系统<br>命令：tree（需要手动下载：yum -y install tree）<br>作用：以树状图来列出目录的内容<br>&#x2F; （简称为 根目录）<br>├── bin -&gt; usr&#x2F;bin<br>├── boot<br>├── dev<br>├── etc——————存放配置文件的文件夹<br>├── home————普通用户的家目录<br>├── lib -&gt; usr&#x2F;lib<br>├── lib64 -&gt; usr&#x2F;lib64<br>├── media<br>├── mnt<br>├── opt<br>├── proc<br>├── root————超级管理员的家目录<br>├── run<br>├── sbin -&gt; usr&#x2F;sbin<br>├── srv<br>├── sys<br>├── tmp————存放临时（缓存）文件的目录<br>├── usr<br>└── var</p>
<p>路径的种类<br>绝对路径：从&#x2F;  目录开始描述的文件或者目录的位置信息</p>
<p>相对路径：从当前目录开始描述的文件或者目录的位置信息</p>
<h2 id="二、切换目录路径"><a href="#二、切换目录路径" class="headerlink" title="二、切换目录路径"></a>二、切换目录路径</h2><p>命令：cd<br>作用：切换命令<br>语法格式：cd 目录路径<br>案例：<br>    cd &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;<br>特殊用法：<br>    cd .. : 返回上一层<br>    cd - : 返回上一次所在目录<br>    cd 或者 cd ~ ：回家</p>
<h2 id="三、Linux文件类型（Linux系统内一切皆是文件）"><a href="#三、Linux文件类型（Linux系统内一切皆是文件）" class="headerlink" title="三、Linux文件类型（Linux系统内一切皆是文件）"></a>三、Linux文件类型（Linux系统内一切皆是文件）</h2><p>普通文件：-<br>目录文件：d<br>链接文件：l<br>块设备文件：b<br>字符设备文件：c<br>套接字文件：s<br>管道文件：p</p>
<h2 id="四、文件和目录的基本操作（增删改查）"><a href="#四、文件和目录的基本操作（增删改查）" class="headerlink" title="四、文件和目录的基本操作（增删改查）"></a>四、文件和目录的基本操作（增删改查）</h2><h3 id="1、创建文件或者目录"><a href="#1、创建文件或者目录" class="headerlink" title="1、创建文件或者目录"></a>1、创建文件或者目录</h3><p>mkdir<br>作用：创建目录<br>语法格式：mkdir [选项] 目录名…<br>常用选项：<br>    -p：创建多级目录（自动创建目录中缺失的父目录）</p>
<p>touch<br>作用：创建文件<br>语法格式：touch 文件名</p>
<h3 id="2、rm"><a href="#2、rm" class="headerlink" title="2、rm"></a>2、rm</h3><p>作用：删除文件<br>语法格式：rm[选项]… 文件名…<br>常用选项：<br>    -r：删除目录<br>    -f：不询问，强制删除<br>注意事项：<br>    rm -rf * ：表示删除当前目录下的所有文件，使用时注意当前所在路径<br>    rm -rf &#x2F;* ：这是传说中删跟跑路，千万不要使用</p>
<h3 id="3、更改文件或者目录"><a href="#3、更改文件或者目录" class="headerlink" title="3、更改文件或者目录"></a>3、更改文件或者目录</h3><p>cp<br>作用：拷贝文件<br>语法格式：cp[选项] 源文件地址 目标文件地址<br>常用选项：<br>    -r：拷贝目录</p>
<p>mv<br>作用：移动文件和目录<br>语法格式：mv 源文件地址 目标文件地址</p>
<h3 id="4、查看文件和目录内容"><a href="#4、查看文件和目录内容" class="headerlink" title="4、查看文件和目录内容"></a>4、查看文件和目录内容</h3><p>查看目录内容<br>ls<br>（略略）</p>
<p>查看文件内容<br>cat		（只适用于查看内容较少的文件）<br>命令：输出文件所有内容<br>语法格式：cat [选项] 文件名<br>常用选项：<br>    -n：带行号显示文件内容</p>
<p>head<br>作用：从文件开头查看<br>语法格式：head [选项] 文件名<br>常用选项：<br>    -n：查看n行（n是数字）</p>
<p>tail<br>作用：从文件结尾查看<br>语法格式：tail [选项] 文件名<br>常用选项：<br>    -n：查看n行（n是数字）</p>
<p>扩展内容<br>管道符 | ：将前一个命令的输出结果作为后面一个命令的操作对象</p>
<h1 id="3-vim编辑器"><a href="#3-vim编辑器" class="headerlink" title="3)vim编辑器"></a>3)vim编辑器</h1><p>vi&#x2F;vim文本编辑器<br>vim是vi的全面升级版，vim需要后期手动下载（yum -y install vim）<br>以下 vi&#x2F;vim 简称 vim</p>
<p>命令：vim<br>作用：文本编辑器<br>语法格式：vim [选项] 文件名</p>
<h2 id="一、vim的三种工作模式"><a href="#一、vim的三种工作模式" class="headerlink" title="一、vim的三种工作模式"></a>一、vim的三种工作模式</h2><p>命令模式（默认模式）：通过快捷键指令可以进行复制粘贴拷贝等操作</p>
<p>编辑模式：可以进行正常的文本内容书写</p>
<p>末行模式：可以进行保存退出以及编辑环境的配置等操作<br>       特征：左下角有：字样，且后面有绿色光标</p>
<p>三种模式的切换：<br>        按esc———&gt;	        &lt;———按esc键<br>编辑模式&lt;————————————&gt;命令模式&lt;————————————&gt;末行模式<br>         &lt;————按i				     打：——&gt;</p>
<p>命令模式下的操作：<br>    gg：跳转到第一行行首<br>    ngg：跳转到第n行行首（n是数字）<br>    G：跳转到文章末行行首<br>    yy:复制光标当前所在行<br>    nyy：复制光标当前所在行往下数n行（n是数字）<br>    dd：剪切光标当前所在行（不粘贴可以当做删除来用）<br>    ndd：剪切光标当前所在行往下数n行（n是数字）<br>    p（P）：将内容粘贴至光标所在行的下（上）一行<br>    dG：将光标所在行到文章末行全部剪切（删除0）<br>    u：撤回<br>    Ctrl + r：撤回我的撤回</p>
<p>编辑模式下的操作：<br>    正常操作</p>
<p>末行模式下的操作：<br>    q ：直接退出<br>    q!：强制退出<br>    w：保存<br>    wq：保存退出<br>    wq!：强制退出<br>    set nu:带行号显示<br>    set nonu：取消行号显示</p>
<h1 id="4-压缩与归档"><a href="#4-压缩与归档" class="headerlink" title="4)压缩与归档"></a>4)压缩与归档</h1><h2 id="一、了解压缩格式"><a href="#一、了解压缩格式" class="headerlink" title="一、了解压缩格式"></a>一、了解压缩格式</h2><p>Windows：zip、rar、7z<br>Linux：gzip（gz）、bzip2（bz2）、xz</p>
<h2 id="二、压缩软件"><a href="#二、压缩软件" class="headerlink" title="二、压缩软件"></a>二、压缩软件</h2><p>命令：gzip<br>作业：压缩工具<br>语法格式：gzip [选项]… 文件名…<br>常用选项：<br>    -r：对目录操作（把目录下的所有文件单独操作）<br>    -d：解压</p>
<h2 id="三、归档与解归档"><a href="#三、归档与解归档" class="headerlink" title="三、归档与解归档"></a>三、归档与解归档</h2><p>命令：tar<br>作用：打包和解包<br>语法格式：tar[选项]… 文件名…<br>常用选项：<br>    -c：打包<br>    -x：解包<br>    -t：看包<br>    -v：看操作过程<br>    -f：指定包的名称<br>    -a：自动压缩&#x2F;解压<br>    -C：将内容解压至指定的文件路径去</p>
<h1 id="5-用户管理"><a href="#5-用户管理" class="headerlink" title="5)用户管理"></a>5)用户管理</h1><h2 id="一、用户和组的概念"><a href="#一、用户和组的概念" class="headerlink" title="一、用户和组的概念"></a>一、用户和组的概念</h2><p>Linux系统里面的用户：对操作系统实现不同功能身份的人<br>组：一个或多个用户的集合<br>对一个组进行授权，就相当于对这个组里面所有的人进行授权，提高了我们授权管理的效率</p>
<h3 id="1、用户和组的关系"><a href="#1、用户和组的关系" class="headerlink" title="1、用户和组的关系"></a>1、用户和组的关系</h3><p>用户可以加入一个组，也可以加入多个组<br>组里面可以没有用户，也可以有多个用户<br>对用户来讲，组分为两种，一种叫做主要组，一种叫做附加组<br>主要组有且只能有一个，附加组可以没有，也可以有多个</p>
<h2 id="二、用户的种类（系统根据uid和gid来判断用户和组的身份，而不是用户和组的名称）"><a href="#二、用户的种类（系统根据uid和gid来判断用户和组的身份，而不是用户和组的名称）" class="headerlink" title="二、用户的种类（系统根据uid和gid来判断用户和组的身份，而不是用户和组的名称）"></a>二、用户的种类（系统根据uid和gid来判断用户和组的身份，而不是用户和组的名称）</h2><p>超级管理员 就是uid为0的用户<br>    注意事项：只要uid为0，它就是超级管理员，拥有最大的特权<br>        gid为0，不意味着拥有特权<br>系统用户也是普通账户，没有特权，一般不可以登录系统，专用程序的运行<br>    uid范围：1-999<br>普通用户就是普通账户，没有特权，一般可以登录系统，专用于人的登录操作<br>    uid范围：1000-？</p>
<h2 id="三、用户的查询"><a href="#三、用户的查询" class="headerlink" title="三、用户的查询"></a>三、用户的查询</h2><p>命令：id<br>语法格式：id 用户名</p>
<h2 id="四、了解-etc-passwd文件"><a href="#四、了解-etc-passwd文件" class="headerlink" title="四、了解&#x2F;etc&#x2F;passwd文件"></a>四、了解&#x2F;etc&#x2F;passwd文件</h2><p>passwd文件保存着系统上所有用户的信息<br>用户名称代指密码:uid:gid:描述信息:家目录:登录环境</p>
<h2 id="五、了解-etc-shadow文件"><a href="#五、了解-etc-shadow文件" class="headerlink" title="五、了解&#x2F;etc&#x2F;shadow文件"></a>五、了解&#x2F;etc&#x2F;shadow文件</h2><p>这个文件保存着所以用户的加密密码</p>
<h2 id="六、了解-etc-skel-目录"><a href="#六、了解-etc-skel-目录" class="headerlink" title="六、了解&#x2F;etc&#x2F;skel&#x2F;目录"></a>六、了解&#x2F;etc&#x2F;skel&#x2F;目录</h2><p>用户的家目录模板</p>
<h2 id="七、创建用户"><a href="#七、创建用户" class="headerlink" title="七、创建用户"></a>七、创建用户</h2><p>命令：useradd<br>语法格式：useradd [选项]… 用户名<br>注意事项：创建用户时，如果没有指定用户的主要组，那么系统就会创建一个与该用户同名的组，<br>并将这个组作为这个用户的主要组<br>常用选项：<br>    -s：设置用户的登录环境<br>    -M：不给用户设置家目录<br>    如何创建一个给程序使用的账户（不给登录系统）<br>    答：useradd -M -s &#x2F;sbin&#x2F;nologin ikun</p>
<h2 id="八、配置用户密码"><a href="#八、配置用户密码" class="headerlink" title="八、配置用户密码"></a>八、配置用户密码</h2><p>命令：passwd<br>语法格式：passwd [用户名]</p>
<p>一、了解权限<br>权限就是权利的限制，主要是针对于普通用户</p>
<p>二、查看权限<br>我们可以使用ls-l的命令来进行文件属性的查看，其中就有我们的文件权限</p>
<h1 id="6-权限管理"><a href="#6-权限管理" class="headerlink" title="6)权限管理"></a>6)权限管理</h1><p>总用量 4<br>-rw——-. 1 root root 1241 11月 12 15:36 anaconda-ks.cfg</p>
<p>其中开头-rw——- 这一段里面，最前面的 - 表示文件类型标识符（这是一个普通文件），<br>后面的这一段共九位 rw——- 就是我们文件的权限标识符</p>
<p>三、unix基础权限（也叫做ugo基础权限）<br> 对文件来讲，可以把用户分为三个大类<br>    u: 文件的所有者<br>        文件的所有者一般是文件的创建者<br>    g: 文件的所属组成员<br>        文件的所属组一般是文件创建者的主要组<br>        注意事项：对组授权一般就是对整个组的用户进行授权<br>    o: 其他人<br>        既不是文件所有者，也不是文件所属组成员的用户，我们统称为其他人</p>
<pre><code>    名称		对目录型文件	对非目录型文件
r	可读权限		查看目录内容	查看文件内容
w	可写		更改目录文件内容	更改文件内容
x	可执行		进入目录		执行文件
            （目录没有x权限，即使有rw权限也使用不了）

文件的权限位有九位，unix权限对应的身份有三种，所以每个身份有三个权限位表示获得
的权限
以下图权限为例
    rw-------			
详解：       rw-			---			---
    第一个三位是所有者的权限	第二个三位是所属组的权限	第三个三位表示的是其他人的权限
</code></pre>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT</title>
    <url>/2024/12/04/MQTT/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>​		MQTT（Message Queuing Telemetry Transport）是一种轻量级的物联网通信协议，基于发布&#x2F;订阅模式，支持QoS级别，适用于低带宽、高延迟的网络环境。它具有精简的协议设计，开放的消息协议，以及广泛应用于物联网、M2M通信、消息推送和智能设备等领域。MQTT协议涉及发布者、订阅者和消息代理（Broker）的角色，以及连接、订阅、发布消息的过程，并包含会话保持和心跳机制，确保消息的可靠传输。</p>
<p>MQTT官方文档：<a href="https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">MQTT Version 3.1.1</a></p>
<h1 id="1-MQTT协议概念"><a href="#1-MQTT协议概念" class="headerlink" title="1 MQTT协议概念:"></a>1 MQTT协议概念:</h1><h3 id="1-1-MQTT特点"><a href="#1-1-MQTT特点" class="headerlink" title="1.1 MQTT特点:"></a>1.1 MQTT特点:</h3><ul>
<li><strong>轻量级</strong>：物联网设备通常在处理能力、内存和能耗方面受到限制。MQTT 开销低、报文小的特点使其非常适合这些设备，因为它消耗更少的资源，即使在有限的能力下也能实现高效的通信。</li>
<li><strong>可靠</strong>：物联网网络常常面临高延迟或连接不稳定的情况。MQTT 支持多种 QoS 等级、会话感知和持久连接，即使在困难的条件下也能保证消息的可靠传递，使其非常适合物联网应用。</li>
<li><strong>安全通信</strong>：安全对于物联网网络至关重要，因为其经常涉及敏感数据的传输。为确保数据在传输过程中的机密性，MQTT 提供传输层安全（TLS）和安全套接层（SSL）加密功能。此外，MQTT 还通过用户名&#x2F;密码凭证或客户端证书提供身份验证和授权机制，以保护网络及其资源的访问。</li>
<li><strong>双向通信</strong>：MQTT 的发布-订阅模式为设备之间提供了无缝的双向通信方式。客户端既可以向主题发布消息，也可以订阅接收特定主题上的消息，从而实现了物联网生态系统中的高效数据交换，而无需直接将设备耦合在一起。这种模式也简化了新设备的集成，同时保证了系统易于扩展。</li>
<li><strong>连续、有状态的会话</strong>：MQTT 提供了客户端与 Broker 之间保持有状态会话的能力，这使得系统即使在断开连接后也能记住订阅和未传递的消息。此外，客户端还可以在建立连接时指定一个保活间隔，这会促使 Broker 定期检查连接状态。如果连接中断，Broker 会储存未传递的消息（根据 QoS 级别确定），并在客户端重新连接时尝试传递它们。这个特性保证了通信的可靠性，降低了因间断性连接而导致数据丢失的风险。</li>
<li><strong>大规模物联网设备支持</strong>：物联网系统往往涉及大量设备，需要一种能够处理大规模部署的协议。MQTT 的轻量级特性、低带宽消耗和对资源的高效利用使其成为大规模物联网应用的理想选择。通过采用发布-订阅模式，MQTT 实现了发送者和接收者的解耦，从而有效地减少了网络流量和资源使用。此外，协议对不同 QoS 等级的支持使得消息传递可以根据需求进行定制，确保在各种场景下获得最佳的性能表现。</li>
</ul>
<h1 id="2-MQTT-的工作原理："><a href="#2-MQTT-的工作原理：" class="headerlink" title="2 MQTT 的工作原理："></a>2 MQTT 的工作原理：</h1><h2 id="2-1-MQTT基本组件"><a href="#2-1-MQTT基本组件" class="headerlink" title="2.1 MQTT基本组件"></a>2.1 MQTT基本组件</h2><p>要了解 MQTT 的工作原理，首先需要掌握以下几个概念：MQTT 客户端、MQTT Broker、发布-订阅模式、主题、QoS。</p>
<p><strong>MQTT 客户端</strong></p>
<p>任何运行 MQTT 客户端库的应用或设备都是 MQTT 客户端。例如，使用 MQTT 的即时通讯应用是客户端，使用 MQTT 上报数据的各种传感器是客户端，各种 MQTT 测试工具也是客户端。客户端可以：</p>
<ol>
<li>发布其他客户端可能会订阅的信息</li>
<li>订阅其他客户端发布的消息</li>
<li>退定或删除应用程序的消息</li>
<li>断开与服务器的连接</li>
</ol>
<p><strong>MQTT 服务端</strong></p>
<p>MQTT Broker 是负责处理客户端请求的关键组件，同时还负责消息的转发。一个高效强大的 MQTT Broker 能够轻松应对海量连接和百万级消息吞吐量，从而帮助物联网服务提供商专注于业务发展，快速构建可靠的 MQTT 应用。 服务端可以：</p>
<ol>
<li>接受来自客户的网络连接</li>
<li>接受客户发布的应用信息</li>
<li>处理来自客户端的订阅和退订请求</li>
<li>向订阅的客户转发应用程序消息</li>
</ol>
<p><strong>发布-订阅模式</strong></p>
<p>发布-订阅模式与客户端-服务器模式的不同之处在于，它将发送消息的客户端（发布者）和接收消息的客户端（订阅者）进行了解耦。发布者和订阅者之间无需建立直接连接，而是通过 MQTT Broker 来负责消息的路由和分发。</p>
<p>下图展示了 MQTT 发布&#x2F;订阅过程。温度传感器作为客户端连接到 MQTT Broker，并通过发布操作将温度数据发布到一个特定主题（例如 <code>Temperature</code>）。MQTT Broker 接收到该消息后会负责将其转发给订阅了相应主题（<code>Temperature</code>）的订阅者客户端。</p>
<p><strong>主题</strong></p>
<p>MQTT 协议根据主题来转发消息。主题通过 <code>/</code> 来区分层级，类似于 URL 路径，例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chat<span class="regexp">/room/</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">sensor<span class="regexp">/10/</span>temperature</span><br><span class="line"></span><br><span class="line">sensor<span class="regexp">/+/</span>temperature</span><br></pre></td></tr></table></figure>

<p>MQTT 主题支持以下两种通配符：<code>+</code> 和 <code>#</code>。</p>
<ul>
<li><code>+</code>：表示单层通配符，例如 <code>a/+</code> 匹配 <code>a/x</code> 或 <code>a/y</code>。</li>
<li><code>#</code>：表示多层通配符，例如 <code>a/#</code> 匹配 <code>a/x</code>、<code>a/b/c/d</code>。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：通配符主题只能用于订阅，不能用于发布。</p>
</blockquote>
<p><strong>QoS</strong></p>
<p>MQTT 提供了三种服务质量（QoS），在不同网络环境下保证消息的可靠性。</p>
<ul>
<li>QoS 0：消息最多传送一次。如果当前客户端不可用，它将丢失这条消息。</li>
<li>QoS 1：消息至少传送一次。</li>
<li>QoS 2：消息只传送一次。</li>
</ul>
<h2 id="2-2-MQTT-的工作流程"><a href="#2-2-MQTT-的工作流程" class="headerlink" title="2.2 MQTT 的工作流程"></a>2.2 MQTT 的工作流程</h2><p>​		实现MQTT协议需要客户端和服务器端通讯完成， 在通讯过程中, MQTT协议中有三种身份: 发布者(Publish)、代理(Broker)(服务器)、订阅者(Subscribe)。 其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<ol>
<li><strong>客户端使用 TCP&#x2F;IP 协议与 Broker 建立连接</strong>，可以选择使用 TLS&#x2F;SSL 加密来实现安全通信。客户端提供认证信息，并指定会话类型（Clean Session 或 Persistent Session）。</li>
<li><strong>客户端既可以向特定主题发布消息，也可以订阅主题以接收消息</strong>。当客户端发布消息时，它会将消息发送给 MQTT Broker；而当客户端订阅消息时，它会接收与订阅主题相关的消息。</li>
<li><strong>MQTT Broker 接收发布的消息</strong>，并将这些消息转发给订阅了对应主题的客户端。它根据 QoS 等级确保消息可靠传递，并根据会话类型为断开连接的客户端存储消息</li>
</ol>
<h2 id="2-3-MQTT协议设计规范"><a href="#2-3-MQTT协议设计规范" class="headerlink" title="2.3  MQTT协议设计规范"></a>2.3  MQTT协议设计规范</h2><ol>
<li><strong>精简</strong>，不添加可有可无的功能；</li>
<li><strong>发布&#x2F;订阅(Pub&#x2F;Sub)模式</strong>，方便消息在传感器之间传递，解耦Client&#x2F;Server模式，带来的好处在于不必预先知道对方的存在(ip&#x2F;port), 不必同时运行</li>
<li>允许用户<strong>动态创建主题</strong>(不需要预先创建主题)，零运维成本；</li>
<li>把传输量降到<strong>最低</strong>以提高传输效率</li>
<li>把<strong>低带宽、高延迟、不稳定</strong>的网络等因素考虑在内；</li>
<li>支持连续的会话保持和控制(<strong>心跳协议</strong>)</li>
<li>客户端<strong>计算能力</strong>要求不高</li>
<li>提供服务质量( quality of service level: <strong>QoS</strong>)管理:</li>
<li>不强求传输数据的类型与格式，<strong>保持灵活性</strong>(指的使应用层业务数据)</li>
</ol>
<h3 id="2-4-MQTT协议主要特性"><a href="#2-4-MQTT协议主要特性" class="headerlink" title="2.4 MQTT协议主要特性"></a>2.4 MQTT协议主要特性</h3><ol>
<li>开放消息协议，简单易实现。</li>
<li>使用发布&#x2F;订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</li>
<li>对负载（协议携带的应用数据）内容屏蔽的消息传输。</li>
<li>基于TCP&#x2F;IP网络连接,提供有序，无损，双向连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。由于基于不同的连接方式，优缺点自然也就各有不同了。</li>
<li>消息服务质量(QoS）支持，可靠传输保证;有三种消息发布服务质量:<br>QoSO:“至多一次”，消息发布完全依赖底层TCP&#x2F;IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。QoS1:“至少—次”，确保消息到达，但消息重复可能会发生。QoS2:“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</li>
<li>1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量。<br>这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</li>
<li>在线状态感知:使用Last Will和Testament特性通知有关各方客户端异常中断的机制。<br>Last Will:即遗言机制，用于通知同一主题下的其他设备，发送遗言的设备已经断开了连接。<br>Testament:遗嘱机制，功能类似于Last Will。</li>
</ol>
<h3 id="2-5-MQTT协议中的方法"><a href="#2-5-MQTT协议中的方法" class="headerlink" title="2.5 MQTT协议中的方法"></a>2.5 MQTT协议中的方法</h3><p>MQTT协议中定义了一些方法(也被称为动作)，来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有:</p>
<ol>
<li>CONNECT: 客户端连接到服务器</li>
<li>CONNACK: 连接确认</li>
<li>PUBLISH: 发布消息</li>
<li>PUBACK: 发布消息确认</li>
<li>PUBREC: 发布的消息已接收</li>
<li>PUBREL: 发布的消息已释放</li>
<li>PUBCOMP: 发布完成</li>
<li>SUBSCRIBE: 订阅请求</li>
<li>SUBACK: 订阅确认</li>
<li>UNSUBSCRIBE: 取消订阅</li>
<li>UNSUBACK: 取消订阅确认</li>
<li>PINGREQ: 客户端发送心跳</li>
<li>PINGRESP: 服务端心跳响应</li>
<li>DISCONNECT: 断开连接</li>
<li>AUTH: 认证</li>
</ol>
<h2 id="3-MQTT协议数据包结构"><a href="#3-MQTT协议数据包结构" class="headerlink" title="3 MQTT协议数据包结构"></a>3 MQTT协议数据包结构</h2><p>​		在MQTT协议中，一个MQTT数据包由: 固定头(Fixed header)、可变头(Variable header)、消息体(payload)三部分构成。</p>
<ol>
<li>固定头(Fixed header)。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识，如连接，发布，订阅，心跳等。其中固定头是必须的，所有类型的MQTT协议中，都必须包含固定头。</li>
<li>可变头(Variable header)。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。可变头部不是可选的意思，而是指这部分在有些协议类型中存在，在有些协议中不存在。</li>
<li>消息体（Payload)。存在于部分MQTT数据包中，表示客户端收到的具体内容。与可变头一样,在有些协议类型中有消息内容，有些协议类型中没有消息内容。</li>
</ol>
<h3 id="3-1-固定头-Fixed-Header"><a href="#3-1-固定头-Fixed-Header" class="headerlink" title="3.1 固定头(Fixed Header)"></a>3.1 固定头(Fixed Header)</h3><pre><code>    固定头存在于所有MQTT数据包中
</code></pre>
<p>固定头包含<strong>两部分</strong>内容：<br>        <strong>首字节(字节1)、</strong><br>        剩余消息报文长度(从第二个字节开始，长度为1-4字节)<br>        剩余长度是当前包中剩余内容长度的字节数，包括变量头和有效负载中的数据)。剩余长度不包含用来编码剩		余长度的字节。<br>        剩余长度使用了一种可变长度的结构来编码，这种结构使用单一字节表示0-127的值。大于127的值如下处理。每个字节的低7位用来编码数据，最高位用来表示是否还有后续字节。因此每个字节可以编码128个值，再加上一个标识位。剩余长度最多可以用四个字节来表示。<br>数据包类型</p>
<p>​		<strong>位置</strong>: 第一个字节(Byte 1)中的7-4个bit被(Bit[7-4]),标识4位无符号值</p>
<p>​		<strong>标志位</strong>：位置: 第一个字节中的0-3个bit位(Bit[3-0])。意思是字节位Bit[3-0]用作报文的标识。<br>首字节的低4位(bit3-bit0)用来表示某些报文类型的控制字段，实际上只有少数报文类型有控制位</p>
<h3 id="3-2-可变头-Variable-Header"><a href="#3-2-可变头-Variable-Header" class="headerlink" title="3.2  可变头(Variable Header)"></a>3.2  可变头(Variable Header)</h3><p>可变头的意思是可变化的消息头部。有些报文类型包含可变头部有些报文则不包含。可变头部在固定头部和消息内容之间，其内容根据报文类型不同而不同</p>
<h3 id="3-3-消息体-Payload"><a href="#3-3-消息体-Payload" class="headerlink" title="3.3  消息体(Payload)"></a>3.3  消息体(Payload)</h3><p>有些报文类型是包含Payload的,Payload的意思是消息载体的意思<br>如PUBLISH的Payload就是指消息内容(应用程序发布的消息内容)。而CONNECT的Payload则包含Client Identifier, Will Topic, Will Message, Username, Password等信息</p>
<p>参考文献：</p>
<p><a href="https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">MQTT Version 3.1.1</a></p>
<p><a href="https://www.emqx.com/zh/blog/category/mqtt-programming">博客 - MQTT 编程 | EMQ</a></p>
<p><a href="https://developer.aliyun.com/article/1261805">MQTT 协议入门：基础知识和快速教程-阿里云开发者社区</a></p>
<p><a href="https://blog.csdn.net/jackwmj12/article/details/129163012">MQTT协议详解(完整版)-CSDN博客</a></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Linux的Nginx搭建与管理</title>
    <url>/2024/11/30/Nginx%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Nginx-简介"><a href="#Nginx-简介" class="headerlink" title="Nginx 简介"></a>Nginx 简介</h2><h3 id="一、Nginx概述"><a href="#一、Nginx概述" class="headerlink" title="一、Nginx概述"></a>一、Nginx概述</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>Nginx（“engine x”）是一个高性能的 HTTP &#x2F;反向代理的服务器及电子邮件（IMAP&#x2F;POP3)代理服务器。</p>
<p><img src="https://s3.qjqq.cn/71/674e800566887.webp!color"></p>
<p>官方测试nginx能够支撑5万并发，并且cpu，内存等资源消耗却非常低，运行非常稳定。最重要的是开源，免费，可商用的。</p>
<p>Nginx还支持热部署，几乎可以做到7 * 24 小时不间断运行，即时运行数个月也不需要重启，还能够在不间断服务的情况下对软件进行升级维护。</p>
<h4 id="1-2-Nginx应用场景"><a href="#1-2-Nginx应用场景" class="headerlink" title="1.2 Nginx应用场景"></a>1.2 Nginx应用场景</h4><p>1、单机环境下参考服务器配置。 并发连接数在7000+ -8000左右。 集群模式20000+。</p>
<p>2、<strong>作为 Web 服务器</strong>：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应。</p>
<p>3、<strong>作为负载均衡服务器</strong>：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。</p>
<p>4、<strong>作为邮件代理服务器</strong>：Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。</p>
<p>5、Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bug非常少的服务器。</p>
<h3 id="二、Nginx安装"><a href="#二、Nginx安装" class="headerlink" title="二、Nginx安装"></a>二、Nginx安装</h3><h4 id="2-1-进入官网下载"><a href="#2-1-进入官网下载" class="headerlink" title="2.1 进入官网下载"></a>2.1 <a href="http://nginx.org/">进入官网下载</a></h4><h4 id="2-2-安装相关依赖"><a href="#2-2-安装相关依赖" class="headerlink" title="2.2 安装相关依赖"></a>2.2 安装相关依赖</h4><h5 id="2-2-1-第一步"><a href="#2-2-1-第一步" class="headerlink" title="2.2.1 第一步"></a>2.2.1 第一步</h5><p>1、 避免：Nginx 与 httpd 发生端口冲突 </p>
<p>卸载：可能已经安装的 httpd，从而避免发生&lt;端口冲突&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(rpm -qa | grep -P <span class="string">&quot;^httpd-([0-9].)+&quot;</span>) &amp;&amp; rpm -e --nodeps httpd || <span class="built_in">echo</span> <span class="string">&quot;未安装&quot;</span> </span><br></pre></td></tr></table></figure>

<p>2、 下载：Nginx 源码安装包，并解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ </span><br><span class="line"><span class="built_in">which</span> wget || yum install -y wget </span><br><span class="line">wget http://nginx.org/download/nginx-1.19.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>3、安装其他依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y gcc pcre-devel zlib-devel </span><br></pre></td></tr></table></figure>

<p>4、创建运行账户nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin nginx</span><br></pre></td></tr></table></figure>

<h4 id="2-3-安装nginx"><a href="#2-3-安装nginx" class="headerlink" title="2.3 安装nginx"></a>2.3 安装nginx</h4><ol>
<li><p>解压nginx-xx.tar.gz包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -axf nginx-1.19.1.tar.gz </span><br></pre></td></tr></table></figure>
</li>
<li><p>进入解压目录，执行.&#x2F;configure 设置安装路径和运行账户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/nginx-1.19.1 </span><br><span class="line">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx </span><br></pre></td></tr></table></figure>
</li>
<li><p>make&amp;&amp;make install</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置网页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;/usr/local/nginx/conf/nginx.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">worker_processes 1;</span></span><br><span class="line"><span class="string">events &#123;</span></span><br><span class="line"><span class="string">    worker_connections  1024;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">http &#123;</span></span><br><span class="line"><span class="string">     include            mime.types;</span></span><br><span class="line"><span class="string">     default_type       application/octet-stream;</span></span><br><span class="line"><span class="string">     sendfile           on;</span></span><br><span class="line"><span class="string">     keepalive_timeout  65;</span></span><br><span class="line"><span class="string">     charset            utf-8;</span></span><br><span class="line"><span class="string">     server &#123;</span></span><br><span class="line"><span class="string">        listen          80;</span></span><br><span class="line"><span class="string">        server_name     localhost;</span></span><br><span class="line"><span class="string">        include         conf.d/*.conf;</span></span><br><span class="line"><span class="string">        location / &#123;</span></span><br><span class="line"><span class="string">            root        html;</span></span><br><span class="line"><span class="string">            index       index.html index.htm;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        error_page 500 502 503 504  /50x.html;</span></span><br><span class="line"><span class="string">            location =  /50x.html &#123;</span></span><br><span class="line"><span class="string">            root        html;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建辅助配置文件目录</span></span><br><span class="line">[ -d /usr/local/nginx/conf/conf.d ] || <span class="built_in">mkdir</span> -p /usr/local/nginx/conf/conf.d</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-3-设置环境变量，同时设置开机自启"><a href="#2-3-设置环境变量，同时设置开机自启" class="headerlink" title="2.3 设置环境变量，同时设置开机自启"></a>2.3 设置环境变量，同时设置开机自启</h4><p>1、设置变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/profile.d/nginx.sh&lt;&lt;<span class="string">EOF </span></span><br><span class="line"><span class="string">export PATH=&quot;/usr/local/nginx/sbin:\$PATH&quot; </span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>2、刷新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile </span><br></pre></td></tr></table></figure>

<p>3、启停：Nginx 服务进程 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/usr/local/nginx/sbin/nginx&quot;</span> &gt;&gt; /etc/rc.d/rc.local 	<span class="comment">## 设置：开机自启动 </span></span><br><span class="line"><span class="built_in">chmod</span> +x /etc/rc.d/rc.local </span><br><span class="line">nginx 或 nginx -c /usr/local/nginx/conf/nginx.conf           <span class="comment">## 启动：Nginx 服务 </span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-访问"><a href="#2-4-访问" class="headerlink" title="2.4 访问"></a>2.4 访问</h4><p>直接浏览器输入虚拟机ip地址测试</p>
<h3 id="三、nginx常用命令和配置文件"><a href="#三、nginx常用命令和配置文件" class="headerlink" title="三、nginx常用命令和配置文件"></a>三、nginx常用命令和配置文件</h3><h4 id="3-1-常用命令"><a href="#3-1-常用命令" class="headerlink" title="3.1 常用命令"></a>3.1 常用命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">nginx -v</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查配置文件错误</span></span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动nginx</span></span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭nginx</span></span><br><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line"><span class="comment">#重加载nginx</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h4 id="3-2-配置文件详细讲解"><a href="#3-2-配置文件详细讲解" class="headerlink" title="3.2 配置文件详细讲解"></a>3.2 配置文件详细讲解</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置文件位置</span></span><br><span class="line">位置：/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">★ 查看：&lt;Nginx 主配置文件&gt;的&lt;默认配置&gt;</span><br><span class="line"><span class="comment"># cat /usr/local/nginx/conf/nginx.conf | grep -vE &quot;^\s*(#|$)&quot;</span></span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">     include            mime.types;</span><br><span class="line">    	<span class="comment">## 导入：&lt;MIME 类型定义配置文件&gt;，其&lt;路径&gt;相对于[当前目录]</span></span><br><span class="line">		<span class="comment">## &lt;mime.type 配置文件&gt;定义：什么类型的&lt;文件&gt;，需用什么&lt;应用组件&gt;打开？</span></span><br><span class="line">     default_type       application/octet-stream;</span><br><span class="line">     sendfile           on;</span><br><span class="line">     keepalive_timeout  65;</span><br><span class="line">     charset            utf-8;	<span class="comment">## 设置语音编码为utf-8，使其页面支持中文</span></span><br><span class="line">     server &#123;</span><br><span class="line">        listen          80;		<span class="comment">## 设置：侦听端口和 IP 地址</span></span><br><span class="line">        server_name     localhost;</span><br><span class="line">        <span class="comment">## 导入：&lt;自定义配置文件&gt;（可以是相对路径 ☚ 以&lt;主配置文件&gt;的&lt;当前目录&gt;为&lt;根目录&gt;）</span></span><br><span class="line">        include         conf.d/*.conf;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root        html;</span><br><span class="line">            index       index.html index.htm;	<span class="comment">## 定义：&lt;默认首页文件名&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504  /50x.html;</span><br><span class="line">            location =  /50x.html &#123;</span><br><span class="line">            root        html;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-理解：的及"><a href="#3-3-理解：的及" class="headerlink" title="3.3 理解：&lt;Nginx 主配置文件&gt;的&lt;语法格式&gt;及&lt;默认配置&gt;"></a>3.3 理解：&lt;Nginx 主配置文件&gt;的&lt;语法格式&gt;及&lt;默认配置&gt;</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">              ┍</span><br><span class="line">main 主配置段 ┤ worker_processes 1; <span class="comment">## 指定：&lt;nginx: worker process 工作进程&gt;的&lt;数量&gt;</span></span><br><span class="line">              │ <span class="comment">## 单 CPU，建议：1 个</span></span><br><span class="line">              │ <span class="comment">## 多 CPU，建议：CPU 总核心数</span></span><br><span class="line">              └</span><br><span class="line">                 ┍ events &#123;</span><br><span class="line">evens 事件配置段 ┤ worker_connections 1024; <span class="comment">## 设置：单个工作进程的&lt;并发最大连接&gt;</span></span><br><span class="line">                 └ &#125;</span><br><span class="line">               ┍ http &#123;</span><br><span class="line">               │ include mime.types;</span><br><span class="line">               │ default_type application/octet-stream;</span><br><span class="line">               │ sendfile on;</span><br><span class="line">               │ keepalive_timeout 65;</span><br><span class="line">               │ server &#123; ─────────────────────────────┐</span><br><span class="line">               │ listen 80;                            │</span><br><span class="line">http 网站配置段 ┤ server_name localhost;                 │</span><br><span class="line">               │ ┍ location / &#123;                        │</span><br><span class="line">               │ │ root html;                          │</span><br><span class="line">               │ │ index index.html index.htm;         ├定义：虚拟主机</span><br><span class="line">               │ └ &#125;                                   │</span><br><span class="line">               │ error_page 500 502 503 504 /50x.html; │</span><br><span class="line">               │ ┍ location = /50x.html &#123;              │</span><br><span class="line">               │ │ root html;                          │</span><br><span class="line">               │ └ &#125;                                   │</span><br><span class="line">               │ &#125;─────────────────────────────────────┘</span><br><span class="line">               └ &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、Nginx反向代理与负载均衡"><a href="#四、Nginx反向代理与负载均衡" class="headerlink" title="四、Nginx反向代理与负载均衡"></a>四、Nginx反向代理与负载均衡</h2><h4 id="4-1-反向代理"><a href="#4-1-反向代理" class="headerlink" title="4.1 反向代理"></a>4.1 反向代理</h4><p><strong>反向代理：</strong>正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好像它自己的一样，一次客户端并会并会不感知到反向代理后面的服务，因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。</p>
<h4 id="4-2-负载均衡"><a href="#4-2-负载均衡" class="headerlink" title="4.2 负载均衡"></a>4.2 负载均衡</h4><p>负载均衡建立在现有网络结构之上，它提供一种链家有效透明的方法扩展网络设备和服务器的宽带、增加吞吐量，加强网络数据处理能力，提高网络的灵活性和可用性。</p>
<h4 id="Nginx-proxy反向代理模块-（默认安装）"><a href="#Nginx-proxy反向代理模块-（默认安装）" class="headerlink" title="Nginx proxy反向代理模块 （默认安装）"></a>Nginx proxy反向代理模块 （默认安装）</h4><p>功能 1：可以作为&lt;应用程序网关&gt;<br>    对外隐藏：&lt;内网服务器&gt;的&lt;IP地址&gt;<br>    对外发布：&lt;内网服务器&gt;的&lt;服务资源&gt;<br>功能 2：可以实现&lt;动静分离&gt;<br>    通过 location URI 地址匹配，实现：转发&lt;动态网页的请求&gt;。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">        location / &#123;		</span><br><span class="line">        proxy_pass http://服务器池;	 </span><br><span class="line">&#125;									<span class="comment">##&lt;上游服务器&gt;指 被反向代理的服务器</span></span><br><span class="line">     或 proxy_pass http://后端服务器池的名字；</span><br><span class="line">     </span><br><span class="line"><span class="comment">## 例如：</span></span><br><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">....</span><br><span class="line">location / &#123;</span><br><span class="line">....</span><br><span class="line">        proxy_pass http://xm;	 </span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h4 id="Nginx-upstream-上游模块（负载均衡）"><a href="#Nginx-upstream-上游模块（负载均衡）" class="headerlink" title="Nginx upstream 上游模块（负载均衡）"></a>Nginx upstream 上游模块（负载均衡）</h4><p>#指令 和 功能<br>upstream		 定义：一个命名的&lt;后端服务器池&gt;<br>server				定义：服务器池里的服务器<br>ip_hash			 启用：基于&lt;IP地址哈希值&gt;的&lt;负载均衡算法&gt;</p>
<h4 id="负载均衡的部署方式"><a href="#负载均衡的部署方式" class="headerlink" title="负载均衡的部署方式"></a>负载均衡的部署方式</h4><p>1.轮询（默认）</p>
<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">....</span><br><span class="line">http &#123;</span><br><span class="line">    upstream xm &#123;	<span class="comment">##xm 服务器池的命名,不要有下划线</span></span><br><span class="line">		server ip地址:80;	<span class="comment">##上游服务器ip:端口</span></span><br><span class="line">		server ip地址:80;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">保存后出去重载文件</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">worker_processes 1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">     include            mime.types;</span><br><span class="line">     default_type       application/octet-stream;</span><br><span class="line">     sendfile           on;</span><br><span class="line">     keepalive_timeout  65;</span><br><span class="line">     charset            utf-8;</span><br><span class="line">     upstream <span class="built_in">test</span> &#123;		<span class="comment">## 定义test组</span></span><br><span class="line">        server 192.168.106.147:80;	<span class="comment">## 定义test组里有那些机器</span></span><br><span class="line">        server 192.168.106.148:80;	<span class="comment">## 这几条ip换成自己web服务器的IP地址</span></span><br><span class="line">     &#125;</span><br><span class="line">     server &#123;</span><br><span class="line">        listen          80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        include         conf.d/*.conf;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root        html;</span><br><span class="line">            index       index.html index.htm;</span><br><span class="line">            proxy_pass  http://test;	<span class="comment">## 有请求就转发到test组</span></span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504  /50x.html;</span><br><span class="line">            location =  /50x.html &#123;</span><br><span class="line">            root        html;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.weight (权重)<br>权重越大，被分配到的任务越多，被访问的概率越高</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">....</span><br><span class="line">http &#123;</span><br><span class="line">	upstream xm &#123;</span><br><span class="line">		server ip地址:80 weight=7;   <span class="comment">#默认weight=1</span></span><br><span class="line">		server ip地址:80 weight=3;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#如上例，分别是70%和30%</span></span><br><span class="line"></span><br><span class="line">保存后出去重载文件</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment">## 例如：</span></span><br><span class="line">worker_processes 1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">     include            mime.types;</span><br><span class="line">     default_type       application/octet-stream;</span><br><span class="line">     sendfile           on;</span><br><span class="line">     keepalive_timeout  65;</span><br><span class="line">     charset            utf-8;</span><br><span class="line">     upstream <span class="built_in">test</span> &#123;	<span class="comment">## 定义test组</span></span><br><span class="line">        server 192.168.106.147:80 weight=7; <span class="comment">## 定义test组内的机器</span></span><br><span class="line">        server 192.168.106.148:80 weight=3; <span class="comment">## 定义test组内的机器</span></span><br><span class="line">     &#125;</span><br><span class="line">     server &#123;</span><br><span class="line">        listen          80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        include         conf.d/*.conf;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root        html;</span><br><span class="line">            index       index.html index.htm;</span><br><span class="line">            proxy_pass  http://test;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504  /50x.html;</span><br><span class="line">            location =  /50x.html &#123;</span><br><span class="line">            root        html;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>3.ip_hash(哈希算法)<br>客户第一次访问某个服务器后短时间断开，再次访问自动定位到该服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">....</span><br><span class="line">http &#123;</span><br><span class="line">	upstream xm &#123;</span><br><span class="line">		ip_hash;</span><br><span class="line">		server ip地址:80;</span><br><span class="line">		server ip地址:80;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">保存后出去重载文件</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">worker_processes 1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">     include            mime.types;</span><br><span class="line">     default_type       application/octet-stream;</span><br><span class="line">     sendfile           on;</span><br><span class="line">     keepalive_timeout  65;</span><br><span class="line">     charset            utf-8;</span><br><span class="line">     upstream <span class="built_in">test</span> &#123;</span><br><span class="line">     	ip_hash;		<span class="comment">## 定义哈希算法</span></span><br><span class="line">        server 192.168.106.147:80;</span><br><span class="line">        server 192.168.106.148:80;</span><br><span class="line">     &#125;</span><br><span class="line">     server &#123;</span><br><span class="line">        listen          80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        include         conf.d/*.conf;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root        html;</span><br><span class="line">            index       index.html index.htm;</span><br><span class="line">            proxy_pass  http://test;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504  /50x.html;</span><br><span class="line">            location =  /50x.html &#123;</span><br><span class="line">            root        html;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五、Nginx-php动静分离"><a href="#五、Nginx-php动静分离" class="headerlink" title="五、Nginx+php动静分离"></a>五、Nginx+php动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。一般来说，都需要将动态资源和静态资源分开，由于Nginx的高并发和静态资源缓存等特性，经常将静态资源部署在Nginx上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是童泰资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<h5 id="1-动态和静态分离主要是通过nginx-PHP-FPM实现的，其中nginx处理图片、html等静态文件，PHP处理动态程序。"><a href="#1-动态和静态分离主要是通过nginx-PHP-FPM实现的，其中nginx处理图片、html等静态文件，PHP处理动态程序。" class="headerlink" title="1. 动态和静态分离主要是通过nginx + PHP FPM实现的，其中nginx处理图片、html等静态文件，PHP处理动态程序。"></a>1. 动态和静态分离主要是通过nginx + PHP FPM实现的，其中nginx处理图片、html等静态文件，PHP处理动态程序。</h5><h5 id="2-动态静态分离是指在web服务器架构中，将静态页面与动态页面或静态内容接口与动态内容接口分离，从而提高整个服务的访问性能和可维护性的架构设计方法。"><a href="#2-动态静态分离是指在web服务器架构中，将静态页面与动态页面或静态内容接口与动态内容接口分离，从而提高整个服务的访问性能和可维护性的架构设计方法。" class="headerlink" title="2. 动态静态分离是指在web服务器架构中，将静态页面与动态页面或静态内容接口与动态内容接口分离，从而提高整个服务的访问性能和可维护性的架构设计方法。"></a>2. 动态静态分离是指在web服务器架构中，将静态页面与动态页面或静态内容接口与动态内容接口分离，从而提高整个服务的访问性能和可维护性的架构设计方法。</h5><h5 id="3-简单地说，当用户请求时，如果他只是访问静态请求，比如图片和html-nginx会直接返回。如果他发送了一个动态请求，nginx会把这个请求发送给程序进行动态处理"><a href="#3-简单地说，当用户请求时，如果他只是访问静态请求，比如图片和html-nginx会直接返回。如果他发送了一个动态请求，nginx会把这个请求发送给程序进行动态处理" class="headerlink" title="3. 简单地说，当用户请求时，如果他只是访问静态请求，比如图片和html, nginx会直接返回。如果他发送了一个动态请求，nginx会把这个请求发送给程序进行动态处理"></a>3. 简单地说，当用户请求时，如果他只是访问静态请求，比如图片和html, nginx会直接返回。如果他发送了一个动态请求，nginx会把这个请求发送给程序进行动态处理</h5><h4 id="1、配合php实现动态页面和静态页面分开处理"><a href="#1、配合php实现动态页面和静态页面分开处理" class="headerlink" title="1、配合php实现动态页面和静态页面分开处理"></a>1、配合php实现动态页面和静态页面分开处理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、删除httpd</span><br><span class="line">rpm -e httpd --nodeps</span><br><span class="line">2、安装php及其组件</span><br><span class="line">yum install -y php php-devel php-mysql</span><br><span class="line">yum install -y php-fpm</span><br><span class="line">3、启动php及其组件，同时将其加入开机自启</span><br><span class="line">systemctl <span class="built_in">enable</span> php-fpm</span><br><span class="line">systemctl start php-fpm</span><br></pre></td></tr></table></figure>

<p>2、修改运行用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i -r <span class="string">&#x27;s/^\s*user\s*=.*/user = nginx/&#x27;</span> /etc/php-fpm.d/www.conf</span><br><span class="line">sed -i -r <span class="string">&#x27;s/^\s*group\s*=.*/group = nginx/&#x27;</span> /etc/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart php-fpm</span><br></pre></td></tr></table></figure>

<p>3、修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/local/nginx/conf/conf.d/location_php.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">location ~ \.php$ &#123;</span></span><br><span class="line"><span class="string">            root           html;</span></span><br><span class="line"><span class="string">            fastcgi_index  index.php;</span></span><br><span class="line"><span class="string">            fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"><span class="string">            include        fastcgi_params;</span></span><br><span class="line"><span class="string">            fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;</span></span><br><span class="line"><span class="string">            if (!-f \$document_root\$fastcgi_script_name) &#123;</span></span><br><span class="line"><span class="string">                        return             404;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>重载nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>4、编写php页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/local/nginx/html/index.php &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&lt;?php</span></span><br><span class="line"><span class="string">            phpinfo();</span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Linux的QQ农场搭建方案</title>
    <url>/2024/11/30/QQ%E5%86%9C%E5%9C%BA%E6%90%AD%E5%BB%BA%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="搭建高可用负载均衡架构—QQ农场项目"><a href="#搭建高可用负载均衡架构—QQ农场项目" class="headerlink" title="搭建高可用负载均衡架构—QQ农场项目"></a>搭建高可用负载均衡架构—QQ农场项目</h1><h2 id="1、事前准备"><a href="#1、事前准备" class="headerlink" title="1、事前准备"></a>1、事前准备</h2><p>负载均衡调度器+keepalived</p>
<p>keepalived-01：192.168.10.11</p>
<p>keepalived-02：192.168.10.12</p>
<p>nginx+php</p>
<p>web-01：192.168.10.13</p>
<p>web-02：192.168.10.14</p>
<p>MySQL数据库</p>
<p>mysql-01：192.168.10.15</p>
<p>NFS网络共享存储</p>
<p>nfs-01：192.168.10.16</p>
<p>关闭防火墙与SELinux、关闭NetworkManager、关闭防火墙firewalld。 </p>
<h2 id="2、部署nginx（keepalived-01、keepalived-02、web-01、web-02）"><a href="#2、部署nginx（keepalived-01、keepalived-02、web-01、web-02）" class="headerlink" title="2、部署nginx（keepalived-01、keepalived-02、web-01、web-02）"></a>2、部署nginx（keepalived-01、keepalived-02、web-01、web-02）</h2><p>1、 避免：Nginx 与 httpd 发生端口冲突 </p>
<p>卸载：可能已经安装的 httpd，从而避免发生&lt;端口冲突&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(rpm -qa | grep -P <span class="string">&quot;^httpd-([0-9].)+&quot;</span>) &amp;&amp; rpm -e --nodeps httpd || <span class="built_in">echo</span> <span class="string">&quot;未安装&quot;</span> </span><br></pre></td></tr></table></figure>

<p>2、 下载：Nginx 源码安装包，并解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ </span><br><span class="line"><span class="built_in">which</span> wget || yum install -y wget </span><br><span class="line">wget http://nginx.org/download/nginx-1.19.7.tar.gz</span><br></pre></td></tr></table></figure>

<p>3、安装其他依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y gcc pcre-devel zlib-devel </span><br></pre></td></tr></table></figure>

<p>4、创建运行账户nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin nginx</span><br></pre></td></tr></table></figure>

<h4 id="2-3-安装nginx"><a href="#2-3-安装nginx" class="headerlink" title="2.3 安装nginx"></a>2.3 安装nginx</h4><ol>
<li><p>解压nginx-xx.tar.gz包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -axf nginx-1.19.7.tar.gz </span><br></pre></td></tr></table></figure>
</li>
<li><p>进入解压目录，执行.&#x2F;configure 设置安装路径和运行账户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/nginx-1.19.7 </span><br><span class="line">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx </span><br></pre></td></tr></table></figure>
</li>
<li><p>make&amp;&amp;make install</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置网页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;/usr/local/nginx/conf/nginx.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">worker_processes 1;</span></span><br><span class="line"><span class="string">events &#123;</span></span><br><span class="line"><span class="string">    worker_connections  1024;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">http &#123;</span></span><br><span class="line"><span class="string">     include            mime.types;</span></span><br><span class="line"><span class="string">     default_type       application/octet-stream;</span></span><br><span class="line"><span class="string">     sendfile           on;</span></span><br><span class="line"><span class="string">     keepalive_timeout  65;</span></span><br><span class="line"><span class="string">     charset            utf-8;</span></span><br><span class="line"><span class="string">     server &#123;</span></span><br><span class="line"><span class="string">        listen          80;</span></span><br><span class="line"><span class="string">        server_name     localhost;</span></span><br><span class="line"><span class="string">		include            conf.d/*.conf;</span></span><br><span class="line"><span class="string">        location / &#123;</span></span><br><span class="line"><span class="string">            root        html;</span></span><br><span class="line"><span class="string">            index       index.html index.htm;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        error_page 500 502 503 504  /50x.html;</span></span><br><span class="line"><span class="string">            location =  /50x.html &#123;</span></span><br><span class="line"><span class="string">            root        html;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建辅助配置文件目录</span></span><br><span class="line">[ -d /usr/local/nginx/conf/conf.d ] || <span class="built_in">mkdir</span> -p /usr/local/nginx/conf/conf.d</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-3-设置环境变量，同时设置开机自启"><a href="#2-3-设置环境变量，同时设置开机自启" class="headerlink" title="2.3 设置环境变量，同时设置开机自启"></a>2.3 设置环境变量，同时设置开机自启</h4><p>1、设置变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/profile.d/nginx.sh&lt;&lt;<span class="string">EOF </span></span><br><span class="line"><span class="string">export PATH=&quot;/usr/local/nginx/sbin:\$PATH&quot; </span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>2、刷新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile </span><br></pre></td></tr></table></figure>

<p>3、启停：Nginx 服务进程 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/usr/local/nginx/sbin/nginx&quot;</span> &gt;&gt; /etc/rc.d/rc.local 	<span class="comment">## 设置：开机自启动 </span></span><br><span class="line"><span class="built_in">chmod</span> +x /etc/rc.d/rc.local </span><br><span class="line">nginx 或 nginx -c /usr/local/nginx/conf/nginx.conf           <span class="comment">## 启动：Nginx 服务 </span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-访问"><a href="#2-4-访问" class="headerlink" title="2.4 访问"></a>2.4 访问</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl 192.168.10.11</span><br><span class="line">curl 192.168.10.12</span><br><span class="line">curl 192.168.10.13</span><br><span class="line">curl 192.168.10.14</span><br></pre></td></tr></table></figure>



<h2 id="3、反向代理-负载均衡-keepalived-01、keepalived-02"><a href="#3、反向代理-负载均衡-keepalived-01、keepalived-02" class="headerlink" title="3、反向代理+负载均衡(keepalived-01、keepalived-02)"></a>3、反向代理+负载均衡(keepalived-01、keepalived-02)</h2><h4 id="Nginx-upstream-上游模块（负载均衡）"><a href="#Nginx-upstream-上游模块（负载均衡）" class="headerlink" title="Nginx upstream 上游模块（负载均衡）"></a>Nginx upstream 上游模块（负载均衡）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">....</span><br><span class="line">http &#123;</span><br><span class="line">    upstream farm &#123;					<span class="comment">##test是服务器池的命名,不要有下划线</span></span><br><span class="line">		server 192.168.10.13:80;	<span class="comment">##上游服务器ip:端口</span></span><br><span class="line">		server 192.168.10.14:80;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Nginx-proxy反向代理模块"><a href="#Nginx-proxy反向代理模块" class="headerlink" title="Nginx proxy反向代理模块"></a>Nginx proxy反向代理模块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">...</span><br><span class="line">location / &#123;		</span><br><span class="line">    proxy_pass http://farm;	</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">保存后出去重载文件</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>



<h2 id="4、安装部署Keepalived软件（keepalived-01、keepalived-02）"><a href="#4、安装部署Keepalived软件（keepalived-01、keepalived-02）" class="headerlink" title="4、安装部署Keepalived软件（keepalived-01、keepalived-02）"></a>4、安装部署Keepalived软件（keepalived-01、keepalived-02）</h2><p>1、安装keepalived软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure>

<h4 id="设置Keepalived配置文件"><a href="#设置Keepalived配置文件" class="headerlink" title="设置Keepalived配置文件"></a>设置Keepalived配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalived/keepalived.conf </span><br></pre></td></tr></table></figure>

<h4 id="keepalived-01操作"><a href="#keepalived-01操作" class="headerlink" title="keepalived-01操作"></a>keepalived-01操作</h4><p>第一步：按冒号：进入末行模式输入set nu 使文件带行号显示，然后使用35gg切换光标到35行，然后按dG，删除35行以 后的所有内容 </p>
<p>第二步：了解一下配置文件中每一行的含义19~34行 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># vrrp_strict		#将这个第十四行注释掉</span></span><br><span class="line">...</span><br><span class="line">vrrp_instance farm &#123;</span><br><span class="line">	state MASTER</span><br><span class="line">	interface ens33</span><br><span class="line">	virtual_router_id 51</span><br><span class="line">	priority 100</span><br><span class="line">	advert_int 1</span><br><span class="line">	authentication &#123;</span><br><span class="line">		auth_type PASS</span><br><span class="line">		auth_pass 1111</span><br><span class="line">	&#125;</span><br><span class="line">	virtual_ipaddress &#123;</span><br><span class="line">		192.168.10.100</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置完成后，保存并退出</p>
<p>第三步：启动Keepalived软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start keepalived</span><br><span class="line">systemctl status keepalived</span><br></pre></td></tr></table></figure>



<h4 id="keepalived-02操作"><a href="#keepalived-02操作" class="headerlink" title="keepalived-02操作"></a>keepalived-02操作</h4><p>第一步：按冒号：进入末行模式输入set nu 使文件带行号显示，然后使用35gg切换光标到35行，然后按dG，删除35行以 后的所有内容 </p>
<p>第二步：了解一下配置文件中每一行的含义19~34行 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># vrrp_strict		#将这个第十四行注释掉</span></span><br><span class="line">...</span><br><span class="line">vrrp_instance farm &#123;</span><br><span class="line">	state BACKUP</span><br><span class="line">	interface ens33</span><br><span class="line">	virtual_router_id 51</span><br><span class="line">	priority 90</span><br><span class="line">	advert_int 1</span><br><span class="line">	authentication &#123;</span><br><span class="line">		auth_type PASS</span><br><span class="line">		auth_pass 1111</span><br><span class="line">	&#125;</span><br><span class="line">	virtual_ipaddress &#123;</span><br><span class="line">		192.168.10.100</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置完成后，保存并退出</p>
<p>第三步：启动Keepalived软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start keepalived</span><br><span class="line">systemctl status keepalived</span><br></pre></td></tr></table></figure>



<h4 id="让Keepalived可以监测Nginx服务（keepalived-01、keepalived-02）"><a href="#让Keepalived可以监测Nginx服务（keepalived-01、keepalived-02）" class="headerlink" title="让Keepalived可以监测Nginx服务（keepalived-01、keepalived-02）"></a>让Keepalived可以监测Nginx服务（keepalived-01、keepalived-02）</h4><p>第一步：编写nginx.sh脚本，自动检测Nginx的运行状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /scripts</span><br><span class="line">vim /scripts/nginx.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">nginx_status=`ps -C nginx --no-header |<span class="built_in">wc</span> -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$nginx_status</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">	systemctl stop keepalived</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>第二步：给nginx.sh文件添加一个可执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /scripts/nginx.sh</span><br></pre></td></tr></table></figure>

<p>第三步：在keepalived-01、keepalived-02两台机器的keepalived.conf文件中配置 nginx.sh脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line">...</span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">	script /scripts/nginx.sh 	<span class="comment">## 指定：&lt;外部脚本&gt;的&lt;调用路径&gt;</span></span><br><span class="line">	interval 1 					<span class="comment">## 设置：&lt;健康跟踪检测&gt;的&lt;时间间隔&gt;，默认为 1 秒</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以上只是在keepalived配置文件中定义了一个检测脚本，但是还没有真正的调用。 </p>
<p>第四步：在vrrp_instance标签中真正调用check_nginx这个检测脚本 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_instance farm &#123;</span><br><span class="line">...</span><br><span class="line">track_script &#123;</span><br><span class="line">check_nginx</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五步：设置完成后，重启keepalived</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> keepalived</span><br><span class="line">systemctl restart keepalived</span><br></pre></td></tr></table></figure>



<h2 id="5、配置nginx-php（web-01、web-02）"><a href="#5、配置nginx-php（web-01、web-02）" class="headerlink" title="5、配置nginx+php（web-01、web-02）"></a>5、配置nginx+php（web-01、web-02）</h2><p>1、安装php服务和插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install php php-fpm php-curl php-intl php-mysql</span><br></pre></td></tr></table></figure>

<p>2、修改nginx配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">...</span><br><span class="line">location / &#123;</span><br><span class="line">	root        /farm;</span><br><span class="line">	index       index.php index.htm;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; /usr/local/nginx/conf/conf.d/farm.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">location ~ \.php$ &#123;</span></span><br><span class="line"><span class="string">    root           /farm;</span></span><br><span class="line"><span class="string">    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"><span class="string">    fastcgi_index  index.php;</span></span><br><span class="line"><span class="string">    fastcgi_param  SCRIPT_FILENAME  \$document_root\$fastcgi_script_name;</span></span><br><span class="line"><span class="string">    include        fastcgi_params;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>3、创建发布目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /farm</span><br></pre></td></tr></table></figure>

<p>4、配置我们的php服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/php.ini</span><br><span class="line"><span class="comment">#short_open_tag，将211行short_open_tag = Off 改为 on</span></span><br></pre></td></tr></table></figure>

<p>5、重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br><span class="line">systemctl <span class="built_in">enable</span> php-fpm</span><br><span class="line">systemctl restart php-fpm</span><br></pre></td></tr></table></figure>


<h2 id="6、配置网络共享存储实现Web网页数据一致（nfs-01）"><a href="#6、配置网络共享存储实现Web网页数据一致（nfs-01）" class="headerlink" title="6、配置网络共享存储实现Web网页数据一致（nfs-01）"></a>6、配置网络共享存储实现Web网页数据一致（nfs-01）</h2><p>1、安装共享存储软件NFS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nfs-utils rpcbind</span><br></pre></td></tr></table></figure>

<p>2、启动软件&amp;设置开机自启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nfs</span><br><span class="line">systemctl start nfs</span><br></pre></td></tr></table></figure>

<p>3、创建共享目录设置权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /php</span><br><span class="line">setfacl -R -m u:nfsnobody:rwx /php</span><br></pre></td></tr></table></figure>

<p>4、将目录设置共享</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/php *(rw)&#x27;</span> &gt; /etc/exports.d/farm.exports</span><br><span class="line">exportfs -r</span><br><span class="line">showmount -e</span><br><span class="line">systemctl restart nfs</span><br></pre></td></tr></table></figure>

<p>5、Web机器下载nfs客户端（web-01、web-02）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nfs-utils</span><br></pre></td></tr></table></figure>

<p>6、挂载该项目目录（web-01、web-02）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount 192.168.100.140:/php /farm</span><br></pre></td></tr></table></figure>



<h2 id="7、配置农场动态页面"><a href="#7、配置农场动态页面" class="headerlink" title="7、配置农场动态页面"></a>7、配置农场动态页面</h2><p>1、下载QQ农场数据包并上传解压（web-01）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">yum -y install lrzsz		<span class="comment">##然后将farm-ucenter1.5.zip包进行上传</span></span><br><span class="line">yum -y install unzip</span><br><span class="line">unzip farm-ucenter1.5.zip	<span class="comment">##解压完会有一个upload目录</span></span><br><span class="line"><span class="built_in">cp</span> -r upload/* /farm</span><br><span class="line"><span class="built_in">cd</span> /farm</span><br><span class="line"><span class="built_in">chmod</span> 777 * -R</span><br></pre></td></tr></table></figure>

<p>2、将&#x2F;farm目录中qqfarm.sql文件通过scp命令发送给mysql-01的MySQL机器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /farm/qqfarm.sql 192.168.10.15:/root/</span><br></pre></td></tr></table></figure>

<h2 id="PS：解决报错问题"><a href="#PS：解决报错问题" class="headerlink" title="PS：解决报错问题"></a>PS：解决报错问题</h2><p>之前许多人做错了导致数据库连接出问题，所以我们需要</p>
<p>1、删除&#x2F;farm目录中所有的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /farm/*</span><br></pre></td></tr></table></figure>

<p>然后执行第七大点的操作</p>
<p>报错后数据库的解决办法在数据库节点下面</p>
<h2 id="8、配置MySQL数据库（mysql-01）"><a href="#8、配置MySQL数据库（mysql-01）" class="headerlink" title="8、配置MySQL数据库（mysql-01）"></a>8、配置MySQL数据库（mysql-01）</h2><p>1、MySQL的安装与初始化设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装mysql</span></span><br><span class="line">yum -y install mariadb-server mariadb</span><br><span class="line">systemctl <span class="built_in">enable</span> mariadb</span><br><span class="line">systemctl start mariadb</span><br><span class="line"><span class="comment">#设置MySQL登录密码</span></span><br><span class="line">初始密码可用来登录，建议我们进入mysql后还是需要修改一下密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">mysqladmin -u root -p<span class="string">&#x27;旧密码&#x27;</span> password <span class="string">&#x27;新密码&#x27;</span>   <span class="comment">#这个不需要进入mysql内就能修改</span></span><br><span class="line">案例:</span><br><span class="line">mysqladmin -u root -p<span class="string">&#x27;旧密码&#x27;</span> password <span class="string">&#x27;Blue@123&#x27;</span></span><br><span class="line">回车两下即可</span><br></pre></td></tr></table></figure>

<p>2、创建farm库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p<span class="string">&#x27;Blue@123&#x27;</span></span><br><span class="line">mysql&gt; create database farm;</span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p> 3、在MySQL服务端，账号登陆并将传输的数据文件导入到新建的farm库中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p<span class="string">&#x27;Blue@123&#x27;</span> farm &lt; /root/qqfarm.sql</span><br></pre></td></tr></table></figure>

<p>4、允许web服务端登陆数据库，需要数据库更改授权，然后重新加载授权表，注意数据库登陆进去以后，命令结尾都要加上；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p<span class="string">&#x27;Blue@123&#x27;</span></span><br><span class="line">create user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;Blue@123&#x27;</span>;</span><br><span class="line">grant all on *.* to <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>



<h2 id="PS：数据库报错的解决办法"><a href="#PS：数据库报错的解决办法" class="headerlink" title="PS：数据库报错的解决办法"></a>PS：数据库报错的解决办法</h2><p>我们需要登陆MySQL，删除原来在farm库，创建新库然后导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p<span class="string">&#x27;Blue@123&#x27;</span></span><br><span class="line">drop database farm;</span><br><span class="line">然后重复执行一遍第八大点的2、3、4小点</span><br></pre></td></tr></table></figure>



<h2 id="9、web服务器端重新启动（web-01、web-02）"><a href="#9、web服务器端重新启动（web-01、web-02）" class="headerlink" title="9、web服务器端重新启动（web-01、web-02）"></a>9、web服务器端重新启动（web-01、web-02）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br><span class="line">systemctl restart php-fpm</span><br></pre></td></tr></table></figure>



<p>五、浏览器访问（访问web-01的ip进行网站安装，安装完毕后再用vip进行访问）</p>
<p>1、在浏览器端输入服务端地址访问，根据提示修改权限</p>
<h5 id="注意数据库服务器一栏填写数据库机器的ip地址"><a href="#注意数据库服务器一栏填写数据库机器的ip地址" class="headerlink" title="注意数据库服务器一栏填写数据库机器的ip地址"></a>注意数据库服务器一栏填写数据库机器的ip地址</h5><p><img src="https://s3.qjqq.cn/71/67529d480e50e.webp!color"></p>
<p>这里下面三个选一个当主页</p>
<p><img src="https://s3.qjqq.cn/71/67529d4823454.webp!color"></p>
<p><img src="https://s3.qjqq.cn/71/67529d4817b39.webp!color"></p>
<p>点完成后会开一个新界面，我们就可以浏览了，这里我们点网络家园</p>
<p><img src="https://s3.qjqq.cn/71/67529d48f1f95.webp!color"></p>
<p>可以看到我们的qq农场，那到底能不能显示出来呢？我们试一试</p>
<p><img src="https://s3.qjqq.cn/71/67529d49543ef.webp!color"></p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>pyGUI(Tk库)</title>
    <url>/2024/12/13/pyGUI(Tk%E5%BA%93)/</url>
    <content><![CDATA[<p>使用Tk库的引用：</p>
<p> import tkinter as tk</p>
<p><strong>创建窗口</strong></p>
<p> a1 &#x3D; tk.TK()</p>
<h1 id="tk-Tk就是创建窗口的函数"><a href="#tk-Tk就是创建窗口的函数" class="headerlink" title="tk.Tk就是创建窗口的函数"></a>tk.Tk就是创建窗口的函数</h1><p><strong>打开窗口</strong></p>
<p>也可以理解为主循环，创建窗口后需要打开窗口，mainloop函数就是用于这个作用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1.mainloop() #mainloop()</span><br></pre></td></tr></table></figure>

<p>是启动这个窗口</p>
<p><strong>设置窗口标题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1.title(&#x27;程序设计&#x27;)</span><br></pre></td></tr></table></figure>



<h1 id="title设置窗口的左上角文字"><a href="#title设置窗口的左上角文字" class="headerlink" title="title设置窗口的左上角文字"></a>title设置窗口的左上角文字</h1><p><strong>设置窗口大小</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1.geometry(&quot;300x300&quot;)</span><br></pre></td></tr></table></figure>



<h1 id="前面的300设置窗口的宽，后面300设置窗口的高"><a href="#前面的300设置窗口的宽，后面300设置窗口的高" class="headerlink" title="前面的300设置窗口的宽，后面300设置窗口的高"></a>前面的300设置窗口的宽，后面300设置窗口的高</h1><p><strong>窗口打开位置</strong></p>
<p>使用的函数还是geometry函数，只是在定义窗口大小后，在后面用加号连接两个数字表示窗口打开时</p>
<p>距离屏幕左边多少像素、距离屏幕顶部多少像素1 a1.geometry(“300x300+200+100”)</p>
<h1 id="a1-geometry-“宽x高-距离屏幕左侧什么位置打开-距离屏幕右侧什么位置打开”"><a href="#a1-geometry-“宽x高-距离屏幕左侧什么位置打开-距离屏幕右侧什么位置打开”" class="headerlink" title="a1.geometry(“宽x高+距离屏幕左侧什么位置打开+距离屏幕右侧什么位置打开”)"></a>a1.geometry(“宽x高+距离屏幕左侧什么位置打开+距离屏幕右侧什么位置打开”)</h1><p><strong>获取用户分辨率</strong></p>
<p>由于每个用户的屏幕分辨率都不一定一样，如果设置窗口大小时给的大小是固定的值，那么会导致窗</p>
<p>口显示比例不一样等问题，所以可以先获取到用户的屏幕分辨率，再根据这个分辨率来设置窗口大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a2 = a1.maxsize()</span><br></pre></td></tr></table></figure>

<p> #注意：获取到的分辨率是一个浮点类型的数，如果后续想要用这个数，要注意是否要类型转换</p>
<p>根据用户屏幕分辨率来创建窗口，可以让窗口无论在哪个分辨率下都是如占屏幕的一半后者全屏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"> a2 = a1.maxsize()</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> k, g = a2 #提取获取到的分辨率，第一个值为长度，第二个值为宽度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #显示的窗口为全屏</span><br><span class="line"></span><br><span class="line"> a1.geometry(f&#x27;&#123;k&#125;x&#123;g&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #显示的窗口为分辨率长、宽的一半,一半就直接乘上0.5就可以</span><br><span class="line"></span><br><span class="line"> #由于获取到的分辨率是浮点类型，但是这里需要整形，所以要有一个强制类型转换</span><br><span class="line"></span><br><span class="line"> a1.geometry(f&#x27;&#123;int(k*0.5)&#125;x&#123;int(g*0.5)&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>锁定窗口缩放</strong></p>
<p>没有设置窗口缩放的话，创建的窗口用户可以自己去改变窗口大小，但是窗口内的控件容易因为窗口</p>
<p>的大小改变受影响，所以一般都是让窗口进行一个大小锁定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1.resizable(False, False) #resizable函数里面可以传入两个参数，并且都是布尔类型</span><br><span class="line"></span><br><span class="line">第一个布尔类型表示是否锁定宽，第二个布尔类型表示是否锁定高，两者默认值都为True，即不锁定</span><br><span class="line"></span><br><span class="line">宽和高**设置窗口左上角图标**</span><br><span class="line"></span><br><span class="line"> a1.iconbitmap(&#x27;logo.ico&#x27;) #icobitmap参数为字符串，用于传入图片途径，同时只支持ICO格</span><br><span class="line"></span><br><span class="line">式的图片</span><br><span class="line"></span><br><span class="line"> #参数传入可以传绝对路径,如下(前面要加上r转义一下)</span><br><span class="line"></span><br><span class="line"> a1.iconbitmap(r&#x27;C:\Users\admin\Desktop\新建文件夹\新建文件夹\pythonProject1\ico&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>设置窗口背景颜色</strong></p>
<p>传入的参数可以是颜色的英文，也可以是颜色的编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1.configure(bg=&#x27;red&#x27;) #可以放颜色的英文，也可以放颜色的编码(#000000)</span><br></pre></td></tr></table></figure>

<p><strong>设置窗口透明度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> a1.attributes(&#x27;-alpha&#x27;, 0) #attributes第一个参数为设置透明度固定传参-alpha，第二个参数</span><br><span class="line"></span><br><span class="line">穿透明值（值的范围在0-1之间的浮点数，如:0.2、0.4等）</span><br></pre></td></tr></table></figure>

<p><strong>设置窗口置顶</strong></p>
<p>窗口置顶就是让该窗口一直显示在屏幕图层的最上方，不会被其他窗口遮挡</p>
<p>该设置调用的函数和设置窗口透明度一样，都是attributes，但是两者传入的参数不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> a1.attributes(&#x27;-topmost&#x27;, True) #第一个为窗口置顶的固定传入参数-topmost，第二个值给True</span><br><span class="line"></span><br><span class="line">表示打开窗口置顶，默认值为False</span><br></pre></td></tr></table></figure>

<p><strong>标签组件</strong></p>
<p>类似于Android中的text组件，用于在窗口中显示文字的，标签组件一般都和填充组合使用，因为只设</p>
<p>置了标签，没有让这个标签填充到窗口中，那么就不会显示标签中的文字了1 a3 &#x3D; tk.Label(a1, text&#x3D;’GUI学习’,font&#x3D;(‘黑体’, 26), fg&#x3D;’blue’, bg&#x3D;’yellow’)</p>
<p>参数1:标签创建在哪个窗口中</p>
<p>参数2:标签显示什么文本，关键字:text</p>
<p>参数3:设置字体，这个参数还有个嵌套参数，第一个参数为想要显示什么样的字体，第二个参数为字体</p>
<p>大小,关键字:font</p>
<p>参数4:设置显示文字的颜色,关键字:fg</p>
<p>参数5:标签的背景颜色,关键字:bg</p>
<p>设置好标签组件之后，还需要使用填充将这个组件填充到窗口中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a3.pack() #填充布局pack，作用就是让前面的标签组件显示出来，要是不写那标签组件就不会显示</span><br></pre></td></tr></table></figure>

<p><strong>Tk****库中的三种填充方式</strong></p>
<p>1.填充布局(pack),也是默认填充,如果不设置创建的窗口大小，那么填充布局就会将填充的东西充满整</p>
<p>个窗口，若窗口设置了大小，那么填充在窗口置顶的中间</p>
<p>2.自定义布局(place),参数1:设置填充距离窗口左侧的距离,参数2:设置填充距离窗口顶部的距离，但是</p>
<p>设置填充的距离不能超过窗口的大小</p>
<p>3.网格布局(grid),可以理解为excel表格,参数一表示行,参数二表示列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #自定义布局</span><br><span class="line"></span><br><span class="line"> a3.place(x=100, y=100) #参数一表示距离窗口左侧多少个像素，参数二表示距离窗口顶部多少个像</span><br><span class="line"></span><br><span class="line">素</span><br><span class="line"></span><br><span class="line"> #网格布局</span><br><span class="line"></span><br><span class="line"> a3.grid(row=1, column=1) #参数一表示行，参数二表示列，这里就是第一行第一列</span><br></pre></td></tr></table></figure>

<p><strong>输入框组件</strong></p>
<p>关键字：Entry</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  tk.Entry(a1, width=15, font=(&#x27;黑体&#x27;, 26)).place(x=550, y=250) #输入组件配置完成后可</span><br><span class="line"></span><br><span class="line">以直接在代码后面设置填充（显示）的位置，不需要像之前一样赋值给变量之后再填充参数1:需要布局在哪个窗口上(窗口对象)</span><br></pre></td></tr></table></figure>

<p>参数2:输入框宽度，不设置的话宽度默认一直到窗口最边缘,关键字:width</p>
<p>参数3:设置字体,这里嵌套传入两个参数，和前面创建标签组件一样，第一个参数为像黑体这样的字</p>
<p>体，第二个参数为字体大小</p>
<p><strong>字符串变量</strong></p>
<p>可以用于获取用户在输入框中输入的内容，如使用get就是获取输入框的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> s1 = tk.StringVar() #使用</span><br><span class="line"></span><br><span class="line">StringVar前提是输入框组件中添加了关键词传参(textvariable),同时导入了字符串变量s1,才能获取到输</span><br><span class="line"></span><br><span class="line">入框的东西</span><br><span class="line"></span><br><span class="line"> s1.set(&#x27;这是一个提示文本&#x27;) #set就像</span><br><span class="line"></span><br><span class="line">提示文本,在输入框中显示一串字符串</span><br><span class="line"></span><br><span class="line"> tk.Entry(a1, textvariable=s1,width=15, font=(&#x27;黑体&#x27;, 26)).place(x=550, y=250) #使用字</span><br><span class="line"></span><br><span class="line">符串变量前提一定是Entry里面添加了textvariable参数并且将对应的字符串变量赋值给它</span><br></pre></td></tr></table></figure>

<p><strong>按钮组件</strong></p>
<p>关键字：Button</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> def dl():</span><br><span class="line"></span><br><span class="line"> print(&quot;Gui&quot;)</span><br><span class="line"></span><br><span class="line"> print(s1.get()) #s1.get是前面字符串变量中的内容,get就是获取用户在输入框</span><br><span class="line"></span><br><span class="line">内输入的内容</span><br><span class="line"></span><br><span class="line"> print(s2.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> tk.Button(a1, text=&#x27;登录&#x27;, font=(&#x27;黑体&#x27;, 25), width=15, command=dl).place(x=400, y=350)</span><br></pre></td></tr></table></figure>

<p>参数1:该按钮在哪一个窗口中</p>
<p>参数2:按钮显示的文字是什么</p>
<p>参数3:按钮字体，设置字体时和前面一样用一个括号传入两个参数</p>
<p>参数4:这个按键的宽度</p>
<p>参数5:传入执行函数,用于点击按钮后需要触发的事件,关键字:command</p>
<p><strong>弹窗组件</strong></p>
<p>注意：使用弹窗组件需要导包：from tkinter import messagebox弹窗组件一共有四种：</p>
<p>1.错误弹窗(showerror)</p>
<p>2.提示弹窗(showinfo)</p>
<p>3.警告弹窗(showwarning)</p>
<p>4.带确定和取消按钮的弹窗(askokcancel)</p>
<p>这四种弹窗函数传入的参数一都是窗口名称,参数二都是窗口显示的内容</p>
<p>弹窗组件顾名思义，就是如点击登入之后弹出的一个小窗口作为提示登录结果，所以下面将会结合按</p>
<p>钮组件来演示弹窗组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> def dl():</span><br><span class="line"></span><br><span class="line"> print(&quot;Gui&quot;)</span><br><span class="line"></span><br><span class="line"> print(s1.get())</span><br><span class="line"></span><br><span class="line"> print(s2.get())</span><br><span class="line"></span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"> 我们将在这个按钮的点击函数中写出弹窗组件的示例</span><br><span class="line"></span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"> if s1.get() != &#x27;123&#x27; or s2.get() != 123: #判断账号和密码是不是正确的</span><br><span class="line"></span><br><span class="line"> print(&#x27;账号或密码错误&#x27;)</span><br><span class="line"></span><br><span class="line"> #显示错误弹窗</span><br><span class="line"></span><br><span class="line"> messagebox.showerror(&#x27;错误&#x27;, &#x27;账号或密码错误&#x27;) #messagebox.showerror是弹出一</span><br><span class="line"></span><br><span class="line">个窗口,参数一为弹窗名称,参数二为弹窗中显示的内容</span><br><span class="line"></span><br><span class="line"> #显示提示弹窗</span><br><span class="line"></span><br><span class="line"> messagebox.showinfo(&#x27;错误&#x27;, &#x27;账号或密码错误&#x27;)</span><br><span class="line"></span><br><span class="line"> #显示警告弹窗</span><br><span class="line"></span><br><span class="line">messagebox.showwarning(&#x27;错误&#x27;, &#x27;账号或密码错误&#x27;)</span><br><span class="line"></span><br><span class="line">#带确定和取消类型弹窗(前三种都是只带确定一个按键的弹窗),这种一般在关闭窗口时弹出等功能</span><br><span class="line"></span><br><span class="line">上运用，即二次确定功能</span><br><span class="line"></span><br><span class="line">#弹窗的确定或取消都可以在函数中定义它的点击事件函数，前提是将这个窗口赋值给一个变量(如</span><br><span class="line"></span><br><span class="line">下)</span><br><span class="line"></span><br><span class="line">d1 = messageboc.askokcancel(&#x27;错误&#x27;, &#x27;账号或密码错误&#x27;)</span><br><span class="line"></span><br><span class="line">if d1: #当点击确定的时候askokcancel返回True</span><br><span class="line"></span><br><span class="line">print(&#x27;确定成功&#x27;)</span><br><span class="line"></span><br><span class="line">else: #当点击取消的时候askokcancel返回False</span><br><span class="line"></span><br><span class="line">print(&#x27;取消成功&#x27;)</span><br><span class="line"></span><br><span class="line">tk.Button(a1, text=&#x27;登录&#x27;, font=(&#x27;黑体&#x27;, 25), width=15, command=dl).place(x=400, y=350)**顶层窗口**</span><br><span class="line"></span><br><span class="line">即内层窗口,除了创建的主窗体以外，其他在主窗口里继续再额外打开的窗口</span><br><span class="line"></span><br><span class="line">在这个窗口中再打开一个新的窗口，这个窗口在标签等方面的设置和前面的窗口设置步骤是一样的,只</span><br><span class="line"></span><br><span class="line">是一开始的引用不一样</span><br><span class="line"></span><br><span class="line">示例使用点击注册按钮时弹出一个注册的窗口</span><br><span class="line"></span><br><span class="line">#注册按键点击函数</span><br><span class="line"></span><br><span class="line">def zc():</span><br><span class="line"></span><br><span class="line">#注册界面设置</span><br><span class="line"></span><br><span class="line">a2 = tk.Toplevel()</span><br><span class="line"></span><br><span class="line">a2.title(&#x27;用户注册&#x27;)</span><br><span class="line"></span><br><span class="line">a2.geometry(&#x27;300x200+400+400&#x27;)</span><br><span class="line"></span><br><span class="line">a2.resizable(False, False)</span><br><span class="line"></span><br><span class="line">tk.Label(a2, text=&#x27;注册账号: &#x27;, font=(&#x27;楷体&#x27;, 15)).grid(row=1, column=1)</span><br><span class="line"></span><br><span class="line">tk.Entry(a2, width=15, font=(&#x27;楷体&#x27;, 15)).grid(row=1, column=2)</span><br><span class="line"></span><br><span class="line">tk.Label(a2, text=&#x27;注册密码: &#x27;, font=(&#x27;楷体&#x27;, 15)).grid(row=2, column=1)</span><br><span class="line"></span><br><span class="line">tk.Entry(a2, width=15, font=(&#x27;楷体&#x27;, 15)).grid(row=2, column=2)</span><br><span class="line"></span><br><span class="line">#注册按键</span><br><span class="line"></span><br><span class="line">tk.Button(a2, text=&#x27;注册&#x27;,font=(&#x27;楷体&#x27;, 15)).place(x=130, y=75)</span><br><span class="line"></span><br><span class="line">#注册按键</span><br><span class="line"></span><br><span class="line">tk.Button(a1, text=&#x27;注册&#x27;, font=(&#x27;黑体&#x27;, 25), width=10, command=zc).place(x=700, y=350)</span><br></pre></td></tr></table></figure>

<p><strong>菜单设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建主菜单</span><br><span class="line"></span><br><span class="line">cai = tk.Menu(a1) #函数传入参数为该擦弹要在哪个窗口上</span><br><span class="line"></span><br><span class="line">#设置菜单名</span><br><span class="line"></span><br><span class="line">cai.add_cascade(label=&#x27;图书管理&#x27;)</span><br><span class="line"></span><br><span class="line">cai.add_cascade(label=&#x27;账号管理&#x27;)</span><br><span class="line"></span><br><span class="line">#开启菜单栏(菜单和前面的标签组件一样，如果没有开启或填充就不会显示到窗口中)</span><br><span class="line"></span><br><span class="line">a1.config(menu=cai) #使用config开启菜单，函数中传入的参数是需要开启对应菜单的名称,如果这</span><br><span class="line"></span><br><span class="line">个菜单名下设置有多个菜单，那么有几个菜单就显示几个菜单</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#下级菜单创建(菜单下拉之后所显示出来的那一部分),调用的函数还是Menu,但是传入的是菜单名称，不是窗</span><br><span class="line"></span><br><span class="line">口名称，因为创建的是下级菜单,如下</span><br><span class="line"></span><br><span class="line">xia = tk.Menu(cai, tearoff=0) #创建下级菜单同时用一个变量接收它,参数2设置的是下拉菜单是</span><br><span class="line"></span><br><span class="line">否有撕开按钮</span><br><span class="line"></span><br><span class="line">#设置下级菜单(实际上创建出来的下级菜单可以理解成为是一个按钮)</span><br><span class="line"></span><br><span class="line">xia.add_command(label=&#x27;图书入库&#x27;, command=&#x27;&#x27;) #参数1为下级菜单名称参数,参数2为点击这</span><br><span class="line"></span><br><span class="line">个下级菜单后的点击事件函数</span><br><span class="line"></span><br><span class="line">#绑定到主菜单</span><br><span class="line"></span><br><span class="line">cai.add_cascade(menu=xia) #但是我们发现前面设置主菜单的时候已经使用到了这个语句，所以我们可</span><br><span class="line"></span><br><span class="line">以将两者合起来</span><br><span class="line"></span><br><span class="line">#cai.add_cascade(label=&#x27;账号管理&#x27;, menu=xia) #合并之后的代码</span><br></pre></td></tr></table></figure>

<p><strong>创建下拉列表（组合框）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用组合框需要导包:from tkinter.ttk import Combobox</span><br><span class="line"></span><br><span class="line">创建的是一个输入框最右边有一个三角形点一下有下拉选项 </span><br><span class="line"></span><br><span class="line">t1 = tk.Toplevel()</span><br><span class="line"></span><br><span class="line">t1.title(&#x27;图书入库&#x27;)</span><br><span class="line"></span><br><span class="line">t1.geometry(&#x27;300x300+200+200&#x27;)</span><br><span class="line"></span><br><span class="line">t1.resizable(False, False)</span><br><span class="line"></span><br><span class="line">tk.Label(t1, text=&#x27;书籍类型: &#x27;, font=(&#x27;楷体&#x27;, 10)).grid(row=1, column=1)</span><br><span class="line"></span><br><span class="line">#创建下拉列表</span><br><span class="line"></span><br><span class="line">t2 = tk.StringVar() #StringVar为使用字符串变</span><br><span class="line"></span><br><span class="line">量时需要引用</span><br><span class="line"></span><br><span class="line">t3 = [&#x27;北京&#x27;, &#x27;深圳&#x27;, &#x27;上海&#x27;] #</span><br><span class="line"></span><br><span class="line">t4 = Combobox(t1, textvariable=t2, value=t3, font=(&#x27;楷体&#x27;, 10), width=10) #参数1表</span><br><span class="line"></span><br><span class="line">示改下拉菜单创建在哪个窗口下,参数2表示让字符串变量显示出来(前面输入框显示提示文本使用过),参数3</span><br><span class="line"></span><br><span class="line">表示下拉菜单下拉后的选项(必须是字符串)</span><br><span class="line"></span><br><span class="line">#或者说参</span><br><span class="line"></span><br><span class="line">数2的textvariable表示绑定了一个字符串变量,参数3的t3表示绑定的字符串变量里面有什么变量</span><br><span class="line"></span><br><span class="line">t4.current(0) #设置下拉列表组件默认显示列表中的哪个,传入参数为列表中的下标</span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line"></span><br><span class="line">t4.grid(row=1, column=2)</span><br><span class="line"></span><br><span class="line">#发现这个下拉列表可以输入东西进去，但实际情况是只让用户通过下拉列表选择，用户不能自己输入任何东</span><br><span class="line"></span><br><span class="line">西，此时可以使用state=&#x27;readonly&#x27;来让这个下拉列表只读，如下</span><br><span class="line"></span><br><span class="line">t4 = Combobox(t1, textvariable=t2, value=t3, font=(&#x27;楷体&#x27;, 10), width=10,</span><br><span class="line"></span><br><span class="line">state=&#x27;readonly&#x27;) #state方法前面输入框使用过</span><br></pre></td></tr></table></figure>

<p><strong>窗口焦点设置</strong></p>
<p>当我们从一个窗口中打开一个新的窗口后，会发现此时焦点还在旧窗口上，若想让焦点在新打开的窗</p>
<p>口上可以使用focus_set函数</p>
<p>t1.focus_set() #设置t1顶层窗口的焦点</p>
<p><strong>设置单选框</strong>**(如选择男或女的一种单选框)**1 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s2 = tk.StringVar(value=&#x27;男&#x27;) #函数中传入参数表示让这个单选框默认选择男</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tk.Radiobutton(t1, text=&#x27;男&#x27;, variable=s2, value=&#x27;男&#x27;).place(x=100, y=100) #用户点了这个单选框那么s2值为男</span><br><span class="line"></span><br><span class="line">tk.Radiobutton(t1, text=&#x27;女&#x27;, variable=s2, value=&#x27;女&#x27;).place(x=100, y=150) #用户点了这个单选框那么s2值为女</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#假设点击了上传按钮之后就输出用户选择了哪个单选框</span><br><span class="line"></span><br><span class="line">def sc():</span><br><span class="line"></span><br><span class="line">print(s2, get()) #打印出用户在单选框中选的内容</span><br><span class="line"></span><br><span class="line">是什么</span><br><span class="line"></span><br><span class="line">tk.Button(t1, text=&#x27;上传&#x27;, command=sc).place(x=300, y=200)</span><br></pre></td></tr></table></figure>

<p>Radiobutton函数参数：</p>
<p>\1. 参数1表示单选框要创建到哪个窗口中</p>
<p>\2. 参数2表示该单选框要显示的文本</p>
<p>\3. 参数3为绑定一个字符串变量</p>
<p>\4. 参数4为绑定的字符串变量里面有什么值(复制给该字符串变量),作用为用户点击了这个</p>
<p>单选框那么s2的值就是男或者女</p>
<p><strong>创建整数变量</strong></p>
<p>在前面我们已经创建了字符串变量，我们可以根据这个来推出如何创建整数变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s3 = tk.IntVar() #创建整数变量</span><br><span class="line"></span><br><span class="line">s4 = tk.StringVar() #创建字符串变量</span><br></pre></td></tr></table></figure>

<p><strong>创建多选框</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s3 = tk.IntVar()</span><br><span class="line"></span><br><span class="line">s4 = tk.IntVar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tk.Checkbutton(t1, text=&#x27;跑步&#x27;, variable=s3, onvalue=1, offvalue=0).place(x=80, y=100)</span><br><span class="line"></span><br><span class="line">tk.Checkbutton(t1, text=&#x27;游泳&#x27;, variable=s4, onvalue=1, offvalue=0).place(x=100, y=100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#同样这里使用一个上传按钮来显示用户选择了哪个多选框</span><br><span class="line"></span><br><span class="line">def sc():</span><br><span class="line"></span><br><span class="line">print(s3.get()) #获取多选框第一个返回的值</span><br><span class="line"></span><br><span class="line">print(s4.get()) #获取多选框第二个返回的值</span><br><span class="line"></span><br><span class="line">if s3.get() == 1: #当用户选择第一个多选框返回1，没有则返回零；第二个多选框也是如此</span><br><span class="line"></span><br><span class="line">print(&#x27;选择了跑步&#x27;)</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line"></span><br><span class="line">print(&#x27;未选择跑步&#x27;)</span><br><span class="line"></span><br><span class="line">if s4.get():</span><br><span class="line"></span><br><span class="line">print(&#x27;选择了游泳&#x27;)</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line"></span><br><span class="line">print(&#x27;未选择游泳&#x27;)</span><br><span class="line"></span><br><span class="line">tk.Button(t1, text=&#x27;上传&#x27;, command=sc).place(x=300, y=400)</span><br></pre></td></tr></table></figure>

<p>Checkbutton函数参数:</p>
<p>\1. 参数1:改多选框创建在哪个窗口下</p>
<p>\2. 参数2:该多选框所显示的文本</p>
<p>\3. 参数3:绑定一个变量</p>
<p>\4. 参数4:当用户选择了这个多选框，该多选框返回的值或者返回的内容</p>
<p>\5. 参数5:当用户没有选择这个多选框,该多选框返回的值或者返回的内容</p>
<p><strong>列表框（<strong><strong>Listbox</strong></strong>）</strong></p>
<p>使用列表框需要导包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tkinter import END1 lb = tk.Listbox(a1, width=40, height=20).place(x=100, y=200)</span><br><span class="line"></span><br><span class="line">#列表框还有一个功能为在列表内追加内容,关键字:insert,参数1表示在列表框末尾追加,参数2表示追加内</span><br><span class="line"></span><br><span class="line">容是什么</span><br><span class="line"></span><br><span class="line">nei = f&#x27;城市:&#123;t2.get()&#125;,性别:&#123;s2,get()&#125;,爱好1:&#123;s3.get()&#125;,爱好2:&#123;s4.get()&#125;&#x27;</span><br><span class="line"></span><br><span class="line">lb.insert(END, nei)</span><br></pre></td></tr></table></figure>

<p>Listbox函数参数：</p>
<p>\1. 参数1:该列表框需要放在哪个窗口下</p>
<p>\2. 参数2:列表框的宽度</p>
<p>\3. 参数3:列表框的高度</p>
<p>注意：如果在Listbox设置了字体的大小，那么列表框的大小将会根据字体大小而变化</p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
</search>
